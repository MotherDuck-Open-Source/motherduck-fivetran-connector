// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: destination_sdk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_destination_5fsdk_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_destination_5fsdk_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_destination_5fsdk_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_destination_5fsdk_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_destination_5fsdk_2eproto;
namespace fivetran_sdk {
class AlterTableRequest;
struct AlterTableRequestDefaultTypeInternal;
extern AlterTableRequestDefaultTypeInternal _AlterTableRequest_default_instance_;
class AlterTableRequest_ConfigurationEntry_DoNotUse;
struct AlterTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern AlterTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _AlterTableRequest_ConfigurationEntry_DoNotUse_default_instance_;
class AlterTableResponse;
struct AlterTableResponseDefaultTypeInternal;
extern AlterTableResponseDefaultTypeInternal _AlterTableResponse_default_instance_;
class CreateTableRequest;
struct CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableRequest_ConfigurationEntry_DoNotUse;
struct CreateTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern CreateTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _CreateTableRequest_ConfigurationEntry_DoNotUse_default_instance_;
class CreateTableResponse;
struct CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class CsvFileParams;
struct CsvFileParamsDefaultTypeInternal;
extern CsvFileParamsDefaultTypeInternal _CsvFileParams_default_instance_;
class DescribeTableRequest;
struct DescribeTableRequestDefaultTypeInternal;
extern DescribeTableRequestDefaultTypeInternal _DescribeTableRequest_default_instance_;
class DescribeTableRequest_ConfigurationEntry_DoNotUse;
struct DescribeTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern DescribeTableRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _DescribeTableRequest_ConfigurationEntry_DoNotUse_default_instance_;
class DescribeTableResponse;
struct DescribeTableResponseDefaultTypeInternal;
extern DescribeTableResponseDefaultTypeInternal _DescribeTableResponse_default_instance_;
class SoftTruncate;
struct SoftTruncateDefaultTypeInternal;
extern SoftTruncateDefaultTypeInternal _SoftTruncate_default_instance_;
class TruncateRequest;
struct TruncateRequestDefaultTypeInternal;
extern TruncateRequestDefaultTypeInternal _TruncateRequest_default_instance_;
class TruncateRequest_ConfigurationEntry_DoNotUse;
struct TruncateRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern TruncateRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _TruncateRequest_ConfigurationEntry_DoNotUse_default_instance_;
class TruncateResponse;
struct TruncateResponseDefaultTypeInternal;
extern TruncateResponseDefaultTypeInternal _TruncateResponse_default_instance_;
class WriteBatchRequest;
struct WriteBatchRequestDefaultTypeInternal;
extern WriteBatchRequestDefaultTypeInternal _WriteBatchRequest_default_instance_;
class WriteBatchRequest_ConfigurationEntry_DoNotUse;
struct WriteBatchRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern WriteBatchRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _WriteBatchRequest_ConfigurationEntry_DoNotUse_default_instance_;
class WriteBatchRequest_KeysEntry_DoNotUse;
struct WriteBatchRequest_KeysEntry_DoNotUseDefaultTypeInternal;
extern WriteBatchRequest_KeysEntry_DoNotUseDefaultTypeInternal _WriteBatchRequest_KeysEntry_DoNotUse_default_instance_;
class WriteBatchResponse;
struct WriteBatchResponseDefaultTypeInternal;
extern WriteBatchResponseDefaultTypeInternal _WriteBatchResponse_default_instance_;
}  // namespace fivetran_sdk
PROTOBUF_NAMESPACE_OPEN
template <>
::fivetran_sdk::AlterTableRequest* Arena::CreateMaybeMessage<::fivetran_sdk::AlterTableRequest>(Arena*);
template <>
::fivetran_sdk::AlterTableRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::AlterTableRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::AlterTableResponse* Arena::CreateMaybeMessage<::fivetran_sdk::AlterTableResponse>(Arena*);
template <>
::fivetran_sdk::CreateTableRequest* Arena::CreateMaybeMessage<::fivetran_sdk::CreateTableRequest>(Arena*);
template <>
::fivetran_sdk::CreateTableRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::CreateTableRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::CreateTableResponse* Arena::CreateMaybeMessage<::fivetran_sdk::CreateTableResponse>(Arena*);
template <>
::fivetran_sdk::CsvFileParams* Arena::CreateMaybeMessage<::fivetran_sdk::CsvFileParams>(Arena*);
template <>
::fivetran_sdk::DescribeTableRequest* Arena::CreateMaybeMessage<::fivetran_sdk::DescribeTableRequest>(Arena*);
template <>
::fivetran_sdk::DescribeTableRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::DescribeTableRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::DescribeTableResponse* Arena::CreateMaybeMessage<::fivetran_sdk::DescribeTableResponse>(Arena*);
template <>
::fivetran_sdk::SoftTruncate* Arena::CreateMaybeMessage<::fivetran_sdk::SoftTruncate>(Arena*);
template <>
::fivetran_sdk::TruncateRequest* Arena::CreateMaybeMessage<::fivetran_sdk::TruncateRequest>(Arena*);
template <>
::fivetran_sdk::TruncateRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::TruncateRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::TruncateResponse* Arena::CreateMaybeMessage<::fivetran_sdk::TruncateResponse>(Arena*);
template <>
::fivetran_sdk::WriteBatchRequest* Arena::CreateMaybeMessage<::fivetran_sdk::WriteBatchRequest>(Arena*);
template <>
::fivetran_sdk::WriteBatchRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::WriteBatchRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::WriteBatchRequest_KeysEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::WriteBatchRequest_KeysEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::WriteBatchResponse* Arena::CreateMaybeMessage<::fivetran_sdk::WriteBatchResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace fivetran_sdk {
enum Encryption : int {
  NONE = 0,
  AES = 1,
  Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Encryption_IsValid(int value);
constexpr Encryption Encryption_MIN = static_cast<Encryption>(0);
constexpr Encryption Encryption_MAX = static_cast<Encryption>(1);
constexpr int Encryption_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Encryption_descriptor();
template <typename T>
const std::string& Encryption_Name(T value) {
  static_assert(std::is_same<T, Encryption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Encryption_Name().");
  return Encryption_Name(static_cast<Encryption>(value));
}
template <>
inline const std::string& Encryption_Name(Encryption value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Encryption_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Encryption_Parse(absl::string_view name, Encryption* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Encryption>(
      Encryption_descriptor(), name, value);
}
enum Compression : int {
  OFF = 0,
  ZSTD = 1,
  GZIP = 2,
  Compression_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Compression_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Compression_IsValid(int value);
constexpr Compression Compression_MIN = static_cast<Compression>(0);
constexpr Compression Compression_MAX = static_cast<Compression>(2);
constexpr int Compression_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Compression_descriptor();
template <typename T>
const std::string& Compression_Name(T value) {
  static_assert(std::is_same<T, Compression>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Compression_Name().");
  return Compression_Name(static_cast<Compression>(value));
}
template <>
inline const std::string& Compression_Name(Compression value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Compression_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Compression_Parse(absl::string_view name, Compression* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Compression>(
      Compression_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class DescribeTableRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DescribeTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DescribeTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DescribeTableRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DescribeTableRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DescribeTableRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DescribeTableRequest_ConfigurationEntry_DoNotUse& other);
  static const DescribeTableRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DescribeTableRequest_ConfigurationEntry_DoNotUse*>(&_DescribeTableRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.DescribeTableRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.DescribeTableRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class DescribeTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.DescribeTableRequest) */ {
 public:
  inline DescribeTableRequest() : DescribeTableRequest(nullptr) {}
  ~DescribeTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DescribeTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeTableRequest(const DescribeTableRequest& from);
  DescribeTableRequest(DescribeTableRequest&& from) noexcept
    : DescribeTableRequest() {
    *this = ::std::move(from);
  }

  inline DescribeTableRequest& operator=(const DescribeTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeTableRequest& operator=(DescribeTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeTableRequest* internal_default_instance() {
    return reinterpret_cast<const DescribeTableRequest*>(
               &_DescribeTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DescribeTableRequest& a, DescribeTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeTableRequest& from) {
    DescribeTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.DescribeTableRequest";
  }
  protected:
  explicit DescribeTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
  };
  // map<string, string> configuration = 1;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // string schema_name = 2;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // string table_name = 3;
  void clear_table_name() ;
  const std::string& table_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name(Arg_&& arg, Args_... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* ptr);

  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(
      const std::string& value);
  std::string* _internal_mutable_table_name();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.DescribeTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DescribeTableRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class DescribeTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.DescribeTableResponse) */ {
 public:
  inline DescribeTableResponse() : DescribeTableResponse(nullptr) {}
  ~DescribeTableResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DescribeTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeTableResponse(const DescribeTableResponse& from);
  DescribeTableResponse(DescribeTableResponse&& from) noexcept
    : DescribeTableResponse() {
    *this = ::std::move(from);
  }

  inline DescribeTableResponse& operator=(const DescribeTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeTableResponse& operator=(DescribeTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeTableResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kNotFound = 1,
    kFailure = 2,
    kTable = 3,
    RESPONSE_NOT_SET = 0,
  };

  static inline const DescribeTableResponse* internal_default_instance() {
    return reinterpret_cast<const DescribeTableResponse*>(
               &_DescribeTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DescribeTableResponse& a, DescribeTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeTableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeTableResponse& from) {
    DescribeTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.DescribeTableResponse";
  }
  protected:
  explicit DescribeTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotFoundFieldNumber = 1,
    kFailureFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // bool not_found = 1;
  bool has_not_found() const;
  void clear_not_found() ;
  bool not_found() const;
  void set_not_found(bool value);

  private:
  bool _internal_not_found() const;
  void _internal_set_not_found(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  // .fivetran_sdk.Table table = 3;
  bool has_table() const;
  private:
  bool _internal_has_table() const;

  public:
  void clear_table() ;
  const ::fivetran_sdk::Table& table() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::Table* release_table();
  ::fivetran_sdk::Table* mutable_table();
  void set_allocated_table(::fivetran_sdk::Table* table);
  private:
  const ::fivetran_sdk::Table& _internal_table() const;
  ::fivetran_sdk::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::fivetran_sdk::Table* table);
  ::fivetran_sdk::Table* unsafe_arena_release_table();
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.DescribeTableResponse)
 private:
  class _Internal;
  void set_has_not_found();
  void set_has_failure();
  void set_has_table();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool not_found_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
      ::fivetran_sdk::Table* table_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class CreateTableRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTableRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTableRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTableRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTableRequest_ConfigurationEntry_DoNotUse& other);
  static const CreateTableRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTableRequest_ConfigurationEntry_DoNotUse*>(&_CreateTableRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.CreateTableRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.CreateTableRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class CreateTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.CreateTableRequest) */ {
 public:
  inline CreateTableRequest() : CreateTableRequest(nullptr) {}
  ~CreateTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableRequest(const CreateTableRequest& from);
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableRequest& from) {
    CreateTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.CreateTableRequest";
  }
  protected:
  explicit CreateTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // map<string, string> configuration = 1;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // string schema_name = 2;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // .fivetran_sdk.Table table = 3;
  bool has_table() const;
  void clear_table() ;
  const ::fivetran_sdk::Table& table() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::Table* release_table();
  ::fivetran_sdk::Table* mutable_table();
  void set_allocated_table(::fivetran_sdk::Table* table);
  private:
  const ::fivetran_sdk::Table& _internal_table() const;
  ::fivetran_sdk::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::fivetran_sdk::Table* table);
  ::fivetran_sdk::Table* unsafe_arena_release_table();
  // @@protoc_insertion_point(class_scope:fivetran_sdk.CreateTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTableRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::fivetran_sdk::Table* table_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class CreateTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.CreateTableResponse) */ {
 public:
  inline CreateTableResponse() : CreateTableResponse(nullptr) {}
  ~CreateTableResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableResponse(const CreateTableResponse& from);
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSuccess = 1,
    kFailure = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableResponse& from) {
    CreateTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.CreateTableResponse";
  }
  protected:
  explicit CreateTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
  };
  // bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.CreateTableResponse)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool success_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class AlterTableRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AlterTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AlterTableRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AlterTableRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlterTableRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AlterTableRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AlterTableRequest_ConfigurationEntry_DoNotUse& other);
  static const AlterTableRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AlterTableRequest_ConfigurationEntry_DoNotUse*>(&_AlterTableRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.AlterTableRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.AlterTableRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class AlterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.AlterTableRequest) */ {
 public:
  inline AlterTableRequest() : AlterTableRequest(nullptr) {}
  ~AlterTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterTableRequest(const AlterTableRequest& from);
  AlterTableRequest(AlterTableRequest&& from) noexcept
    : AlterTableRequest() {
    *this = ::std::move(from);
  }

  inline AlterTableRequest& operator=(const AlterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterTableRequest& operator=(AlterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlterTableRequest* internal_default_instance() {
    return reinterpret_cast<const AlterTableRequest*>(
               &_AlterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AlterTableRequest& a, AlterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterTableRequest& from) {
    AlterTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.AlterTableRequest";
  }
  protected:
  explicit AlterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // map<string, string> configuration = 1;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // string schema_name = 2;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // .fivetran_sdk.Table table = 3;
  bool has_table() const;
  void clear_table() ;
  const ::fivetran_sdk::Table& table() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::Table* release_table();
  ::fivetran_sdk::Table* mutable_table();
  void set_allocated_table(::fivetran_sdk::Table* table);
  private:
  const ::fivetran_sdk::Table& _internal_table() const;
  ::fivetran_sdk::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::fivetran_sdk::Table* table);
  ::fivetran_sdk::Table* unsafe_arena_release_table();
  // @@protoc_insertion_point(class_scope:fivetran_sdk.AlterTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AlterTableRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::fivetran_sdk::Table* table_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class AlterTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.AlterTableResponse) */ {
 public:
  inline AlterTableResponse() : AlterTableResponse(nullptr) {}
  ~AlterTableResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlterTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterTableResponse(const AlterTableResponse& from);
  AlterTableResponse(AlterTableResponse&& from) noexcept
    : AlterTableResponse() {
    *this = ::std::move(from);
  }

  inline AlterTableResponse& operator=(const AlterTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterTableResponse& operator=(AlterTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterTableResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSuccess = 1,
    kFailure = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const AlterTableResponse* internal_default_instance() {
    return reinterpret_cast<const AlterTableResponse*>(
               &_AlterTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AlterTableResponse& a, AlterTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterTableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterTableResponse& from) {
    AlterTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.AlterTableResponse";
  }
  protected:
  explicit AlterTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
  };
  // bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.AlterTableResponse)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool success_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class TruncateRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TruncateRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TruncateRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TruncateRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TruncateRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TruncateRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TruncateRequest_ConfigurationEntry_DoNotUse& other);
  static const TruncateRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TruncateRequest_ConfigurationEntry_DoNotUse*>(&_TruncateRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.TruncateRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.TruncateRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class TruncateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.TruncateRequest) */ {
 public:
  inline TruncateRequest() : TruncateRequest(nullptr) {}
  ~TruncateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TruncateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateRequest(const TruncateRequest& from);
  TruncateRequest(TruncateRequest&& from) noexcept
    : TruncateRequest() {
    *this = ::std::move(from);
  }

  inline TruncateRequest& operator=(const TruncateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateRequest& operator=(TruncateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateRequest* internal_default_instance() {
    return reinterpret_cast<const TruncateRequest*>(
               &_TruncateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TruncateRequest& a, TruncateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateRequest& from) {
    TruncateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.TruncateRequest";
  }
  protected:
  explicit TruncateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kSyncedColumnFieldNumber = 4,
    kUtcDeleteBeforeFieldNumber = 5,
    kSoftFieldNumber = 6,
  };
  // map<string, string> configuration = 1;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // string schema_name = 2;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // string table_name = 3;
  void clear_table_name() ;
  const std::string& table_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name(Arg_&& arg, Args_... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* ptr);

  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(
      const std::string& value);
  std::string* _internal_mutable_table_name();

  public:
  // string synced_column = 4;
  void clear_synced_column() ;
  const std::string& synced_column() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_synced_column(Arg_&& arg, Args_... args);
  std::string* mutable_synced_column();
  PROTOBUF_NODISCARD std::string* release_synced_column();
  void set_allocated_synced_column(std::string* ptr);

  private:
  const std::string& _internal_synced_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_synced_column(
      const std::string& value);
  std::string* _internal_mutable_synced_column();

  public:
  // .google.protobuf.Timestamp utc_delete_before = 5;
  bool has_utc_delete_before() const;
  void clear_utc_delete_before() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& utc_delete_before() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_utc_delete_before();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_utc_delete_before();
  void set_allocated_utc_delete_before(::PROTOBUF_NAMESPACE_ID::Timestamp* utc_delete_before);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_utc_delete_before() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_utc_delete_before();
  public:
  void unsafe_arena_set_allocated_utc_delete_before(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* utc_delete_before);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_utc_delete_before();
  // optional .fivetran_sdk.SoftTruncate soft = 6;
  bool has_soft() const;
  void clear_soft() ;
  const ::fivetran_sdk::SoftTruncate& soft() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::SoftTruncate* release_soft();
  ::fivetran_sdk::SoftTruncate* mutable_soft();
  void set_allocated_soft(::fivetran_sdk::SoftTruncate* soft);
  private:
  const ::fivetran_sdk::SoftTruncate& _internal_soft() const;
  ::fivetran_sdk::SoftTruncate* _internal_mutable_soft();
  public:
  void unsafe_arena_set_allocated_soft(
      ::fivetran_sdk::SoftTruncate* soft);
  ::fivetran_sdk::SoftTruncate* unsafe_arena_release_soft();
  // @@protoc_insertion_point(class_scope:fivetran_sdk.TruncateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TruncateRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr synced_column_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* utc_delete_before_;
    ::fivetran_sdk::SoftTruncate* soft_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class SoftTruncate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.SoftTruncate) */ {
 public:
  inline SoftTruncate() : SoftTruncate(nullptr) {}
  ~SoftTruncate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SoftTruncate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoftTruncate(const SoftTruncate& from);
  SoftTruncate(SoftTruncate&& from) noexcept
    : SoftTruncate() {
    *this = ::std::move(from);
  }

  inline SoftTruncate& operator=(const SoftTruncate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftTruncate& operator=(SoftTruncate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftTruncate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftTruncate* internal_default_instance() {
    return reinterpret_cast<const SoftTruncate*>(
               &_SoftTruncate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SoftTruncate& a, SoftTruncate& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftTruncate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftTruncate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftTruncate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoftTruncate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoftTruncate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SoftTruncate& from) {
    SoftTruncate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftTruncate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.SoftTruncate";
  }
  protected:
  explicit SoftTruncate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedColumnFieldNumber = 3,
  };
  // string deleted_column = 3;
  void clear_deleted_column() ;
  const std::string& deleted_column() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deleted_column(Arg_&& arg, Args_... args);
  std::string* mutable_deleted_column();
  PROTOBUF_NODISCARD std::string* release_deleted_column();
  void set_allocated_deleted_column(std::string* ptr);

  private:
  const std::string& _internal_deleted_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_column(
      const std::string& value);
  std::string* _internal_mutable_deleted_column();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.SoftTruncate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_column_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class TruncateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.TruncateResponse) */ {
 public:
  inline TruncateResponse() : TruncateResponse(nullptr) {}
  ~TruncateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TruncateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateResponse(const TruncateResponse& from);
  TruncateResponse(TruncateResponse&& from) noexcept
    : TruncateResponse() {
    *this = ::std::move(from);
  }

  inline TruncateResponse& operator=(const TruncateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateResponse& operator=(TruncateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSuccess = 1,
    kFailure = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const TruncateResponse* internal_default_instance() {
    return reinterpret_cast<const TruncateResponse*>(
               &_TruncateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TruncateResponse& a, TruncateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateResponse& from) {
    TruncateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.TruncateResponse";
  }
  protected:
  explicit TruncateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
  };
  // bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.TruncateResponse)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool success_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class WriteBatchRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteBatchRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteBatchRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WriteBatchRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteBatchRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WriteBatchRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WriteBatchRequest_ConfigurationEntry_DoNotUse& other);
  static const WriteBatchRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WriteBatchRequest_ConfigurationEntry_DoNotUse*>(&_WriteBatchRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.WriteBatchRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.WriteBatchRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class WriteBatchRequest_KeysEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteBatchRequest_KeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteBatchRequest_KeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  WriteBatchRequest_KeysEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteBatchRequest_KeysEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WriteBatchRequest_KeysEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WriteBatchRequest_KeysEntry_DoNotUse& other);
  static const WriteBatchRequest_KeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WriteBatchRequest_KeysEntry_DoNotUse*>(&_WriteBatchRequest_KeysEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.WriteBatchRequest.KeysEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class WriteBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.WriteBatchRequest) */ {
 public:
  inline WriteBatchRequest() : WriteBatchRequest(nullptr) {}
  ~WriteBatchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WriteBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteBatchRequest(const WriteBatchRequest& from);
  WriteBatchRequest(WriteBatchRequest&& from) noexcept
    : WriteBatchRequest() {
    *this = ::std::move(from);
  }

  inline WriteBatchRequest& operator=(const WriteBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteBatchRequest& operator=(WriteBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  enum FileParamsCase {
    kCsv = 8,
    FILE_PARAMS_NOT_SET = 0,
  };

  static inline const WriteBatchRequest* internal_default_instance() {
    return reinterpret_cast<const WriteBatchRequest*>(
               &_WriteBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WriteBatchRequest& a, WriteBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteBatchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteBatchRequest& from) {
    WriteBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.WriteBatchRequest";
  }
  protected:
  explicit WriteBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kKeysFieldNumber = 4,
    kReplaceFilesFieldNumber = 5,
    kUpdateFilesFieldNumber = 6,
    kDeleteFilesFieldNumber = 7,
    kSchemaNameFieldNumber = 2,
    kTableFieldNumber = 3,
    kCsvFieldNumber = 8,
  };
  // map<string, string> configuration = 1;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // map<string, bytes> keys = 4;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_keys();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_keys();
  // repeated string replace_files = 5;
  int replace_files_size() const;
  private:
  int _internal_replace_files_size() const;

  public:
  void clear_replace_files() ;
  const std::string& replace_files(int index) const;
  std::string* mutable_replace_files(int index);
  void set_replace_files(int index, const std::string& value);
  void set_replace_files(int index, std::string&& value);
  void set_replace_files(int index, const char* value);
  void set_replace_files(int index, const char* value, std::size_t size);
  void set_replace_files(int index, absl::string_view value);
  std::string* add_replace_files();
  void add_replace_files(const std::string& value);
  void add_replace_files(std::string&& value);
  void add_replace_files(const char* value);
  void add_replace_files(const char* value, std::size_t size);
  void add_replace_files(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replace_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replace_files();

  private:
  const std::string& _internal_replace_files(int index) const;
  std::string* _internal_add_replace_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_replace_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_replace_files();

  public:
  // repeated string update_files = 6;
  int update_files_size() const;
  private:
  int _internal_update_files_size() const;

  public:
  void clear_update_files() ;
  const std::string& update_files(int index) const;
  std::string* mutable_update_files(int index);
  void set_update_files(int index, const std::string& value);
  void set_update_files(int index, std::string&& value);
  void set_update_files(int index, const char* value);
  void set_update_files(int index, const char* value, std::size_t size);
  void set_update_files(int index, absl::string_view value);
  std::string* add_update_files();
  void add_update_files(const std::string& value);
  void add_update_files(std::string&& value);
  void add_update_files(const char* value);
  void add_update_files(const char* value, std::size_t size);
  void add_update_files(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& update_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_update_files();

  private:
  const std::string& _internal_update_files(int index) const;
  std::string* _internal_add_update_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_update_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_update_files();

  public:
  // repeated string delete_files = 7;
  int delete_files_size() const;
  private:
  int _internal_delete_files_size() const;

  public:
  void clear_delete_files() ;
  const std::string& delete_files(int index) const;
  std::string* mutable_delete_files(int index);
  void set_delete_files(int index, const std::string& value);
  void set_delete_files(int index, std::string&& value);
  void set_delete_files(int index, const char* value);
  void set_delete_files(int index, const char* value, std::size_t size);
  void set_delete_files(int index, absl::string_view value);
  std::string* add_delete_files();
  void add_delete_files(const std::string& value);
  void add_delete_files(std::string&& value);
  void add_delete_files(const char* value);
  void add_delete_files(const char* value, std::size_t size);
  void add_delete_files(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delete_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delete_files();

  private:
  const std::string& _internal_delete_files(int index) const;
  std::string* _internal_add_delete_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_delete_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_delete_files();

  public:
  // string schema_name = 2;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // .fivetran_sdk.Table table = 3;
  bool has_table() const;
  void clear_table() ;
  const ::fivetran_sdk::Table& table() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::Table* release_table();
  ::fivetran_sdk::Table* mutable_table();
  void set_allocated_table(::fivetran_sdk::Table* table);
  private:
  const ::fivetran_sdk::Table& _internal_table() const;
  ::fivetran_sdk::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::fivetran_sdk::Table* table);
  ::fivetran_sdk::Table* unsafe_arena_release_table();
  // .fivetran_sdk.CsvFileParams csv = 8;
  bool has_csv() const;
  private:
  bool _internal_has_csv() const;

  public:
  void clear_csv() ;
  const ::fivetran_sdk::CsvFileParams& csv() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::CsvFileParams* release_csv();
  ::fivetran_sdk::CsvFileParams* mutable_csv();
  void set_allocated_csv(::fivetran_sdk::CsvFileParams* csv);
  private:
  const ::fivetran_sdk::CsvFileParams& _internal_csv() const;
  ::fivetran_sdk::CsvFileParams* _internal_mutable_csv();
  public:
  void unsafe_arena_set_allocated_csv(
      ::fivetran_sdk::CsvFileParams* csv);
  ::fivetran_sdk::CsvFileParams* unsafe_arena_release_csv();
  void clear_file_params();
  FileParamsCase file_params_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.WriteBatchRequest)
 private:
  class _Internal;
  void set_has_csv();

  inline bool has_file_params() const;
  inline void clear_has_file_params();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WriteBatchRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WriteBatchRequest_KeysEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replace_files_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> update_files_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delete_files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::fivetran_sdk::Table* table_;
    union FileParamsUnion {
      constexpr FileParamsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fivetran_sdk::CsvFileParams* csv_;
    } file_params_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class CsvFileParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.CsvFileParams) */ {
 public:
  inline CsvFileParams() : CsvFileParams(nullptr) {}
  ~CsvFileParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CsvFileParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CsvFileParams(const CsvFileParams& from);
  CsvFileParams(CsvFileParams&& from) noexcept
    : CsvFileParams() {
    *this = ::std::move(from);
  }

  inline CsvFileParams& operator=(const CsvFileParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline CsvFileParams& operator=(CsvFileParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CsvFileParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const CsvFileParams* internal_default_instance() {
    return reinterpret_cast<const CsvFileParams*>(
               &_CsvFileParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CsvFileParams& a, CsvFileParams& b) {
    a.Swap(&b);
  }
  inline void Swap(CsvFileParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CsvFileParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CsvFileParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CsvFileParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CsvFileParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CsvFileParams& from) {
    CsvFileParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CsvFileParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.CsvFileParams";
  }
  protected:
  explicit CsvFileParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullStringFieldNumber = 3,
    kUnmodifiedStringFieldNumber = 4,
    kCompressionFieldNumber = 1,
    kEncryptionFieldNumber = 2,
  };
  // string null_string = 3;
  void clear_null_string() ;
  const std::string& null_string() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_null_string(Arg_&& arg, Args_... args);
  std::string* mutable_null_string();
  PROTOBUF_NODISCARD std::string* release_null_string();
  void set_allocated_null_string(std::string* ptr);

  private:
  const std::string& _internal_null_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_null_string(
      const std::string& value);
  std::string* _internal_mutable_null_string();

  public:
  // string unmodified_string = 4;
  void clear_unmodified_string() ;
  const std::string& unmodified_string() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unmodified_string(Arg_&& arg, Args_... args);
  std::string* mutable_unmodified_string();
  PROTOBUF_NODISCARD std::string* release_unmodified_string();
  void set_allocated_unmodified_string(std::string* ptr);

  private:
  const std::string& _internal_unmodified_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unmodified_string(
      const std::string& value);
  std::string* _internal_mutable_unmodified_string();

  public:
  // .fivetran_sdk.Compression compression = 1;
  void clear_compression() ;
  ::fivetran_sdk::Compression compression() const;
  void set_compression(::fivetran_sdk::Compression value);

  private:
  ::fivetran_sdk::Compression _internal_compression() const;
  void _internal_set_compression(::fivetran_sdk::Compression value);

  public:
  // .fivetran_sdk.Encryption encryption = 2;
  void clear_encryption() ;
  ::fivetran_sdk::Encryption encryption() const;
  void set_encryption(::fivetran_sdk::Encryption value);

  private:
  ::fivetran_sdk::Encryption _internal_encryption() const;
  void _internal_set_encryption(::fivetran_sdk::Encryption value);

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.CsvFileParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr null_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unmodified_string_;
    int compression_;
    int encryption_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};// -------------------------------------------------------------------

class WriteBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.WriteBatchResponse) */ {
 public:
  inline WriteBatchResponse() : WriteBatchResponse(nullptr) {}
  ~WriteBatchResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WriteBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteBatchResponse(const WriteBatchResponse& from);
  WriteBatchResponse(WriteBatchResponse&& from) noexcept
    : WriteBatchResponse() {
    *this = ::std::move(from);
  }

  inline WriteBatchResponse& operator=(const WriteBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteBatchResponse& operator=(WriteBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSuccess = 1,
    kFailure = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const WriteBatchResponse* internal_default_instance() {
    return reinterpret_cast<const WriteBatchResponse*>(
               &_WriteBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WriteBatchResponse& a, WriteBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteBatchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteBatchResponse& from) {
    WriteBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.WriteBatchResponse";
  }
  protected:
  explicit WriteBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
  };
  // bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.WriteBatchResponse)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool success_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_destination_5fsdk_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DescribeTableRequest

// map<string, string> configuration = 1;
inline int DescribeTableRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int DescribeTableRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void DescribeTableRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DescribeTableRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DescribeTableRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.DescribeTableRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DescribeTableRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DescribeTableRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.DescribeTableRequest.configuration)
  return _internal_mutable_configuration();
}

// string schema_name = 2;
inline void DescribeTableRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DescribeTableRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DescribeTableRequest.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DescribeTableRequest::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.DescribeTableRequest.schema_name)
}
inline std::string* DescribeTableRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.DescribeTableRequest.schema_name)
  return _s;
}
inline const std::string& DescribeTableRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DescribeTableRequest::_internal_set_schema_name(const std::string& value) {
  ;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::_internal_mutable_schema_name() {
  ;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.DescribeTableRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DescribeTableRequest::set_allocated_schema_name(std::string* value) {
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.DescribeTableRequest.schema_name)
}

// string table_name = 3;
inline void DescribeTableRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DescribeTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DescribeTableRequest.table_name)
  return _internal_table_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DescribeTableRequest::set_table_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.table_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.DescribeTableRequest.table_name)
}
inline std::string* DescribeTableRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.DescribeTableRequest.table_name)
  return _s;
}
inline const std::string& DescribeTableRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DescribeTableRequest::_internal_set_table_name(const std::string& value) {
  ;


  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::_internal_mutable_table_name() {
  ;
  return _impl_.table_name_.Mutable( GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.DescribeTableRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void DescribeTableRequest::set_allocated_table_name(std::string* value) {
  _impl_.table_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_name_.IsDefault()) {
          _impl_.table_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.DescribeTableRequest.table_name)
}

// -------------------------------------------------------------------

// DescribeTableResponse

// bool not_found = 1;
inline bool DescribeTableResponse::has_not_found() const {
  return response_case() == kNotFound;
}
inline void DescribeTableResponse::set_has_not_found() {
  _impl_._oneof_case_[0] = kNotFound;
}
inline void DescribeTableResponse::clear_not_found() {
  if (response_case() == kNotFound) {
    _impl_.response_.not_found_ = false;
    clear_has_response();
  }
}
inline bool DescribeTableResponse::not_found() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DescribeTableResponse.not_found)
  return _internal_not_found();
}
inline void DescribeTableResponse::set_not_found(bool value) {
  _internal_set_not_found(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.DescribeTableResponse.not_found)
}
inline bool DescribeTableResponse::_internal_not_found() const {
  if (response_case() == kNotFound) {
    return _impl_.response_.not_found_;
  }
  return false;
}
inline void DescribeTableResponse::_internal_set_not_found(bool value) {
  if (response_case() != kNotFound) {
    clear_response();
    set_has_not_found();
  }
  _impl_.response_.not_found_ = value;
}

// string failure = 2;
inline bool DescribeTableResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void DescribeTableResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void DescribeTableResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& DescribeTableResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DescribeTableResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DescribeTableResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.DescribeTableResponse.failure)
}
inline std::string* DescribeTableResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.DescribeTableResponse.failure)
  return _s;
}
inline const std::string& DescribeTableResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void DescribeTableResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeTableResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* DescribeTableResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.DescribeTableResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void DescribeTableResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.DescribeTableResponse.failure)
}

// .fivetran_sdk.Table table = 3;
inline bool DescribeTableResponse::has_table() const {
  return response_case() == kTable;
}
inline bool DescribeTableResponse::_internal_has_table() const {
  return response_case() == kTable;
}
inline void DescribeTableResponse::set_has_table() {
  _impl_._oneof_case_[0] = kTable;
}
inline ::fivetran_sdk::Table* DescribeTableResponse::release_table() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.DescribeTableResponse.table)
  if (response_case() == kTable) {
    clear_has_response();
    ::fivetran_sdk::Table* temp = _impl_.response_.table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fivetran_sdk::Table& DescribeTableResponse::_internal_table() const {
  return response_case() == kTable
      ? *_impl_.response_.table_
      : reinterpret_cast<::fivetran_sdk::Table&>(::fivetran_sdk::_Table_default_instance_);
}
inline const ::fivetran_sdk::Table& DescribeTableResponse::table() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DescribeTableResponse.table)
  return _internal_table();
}
inline ::fivetran_sdk::Table* DescribeTableResponse::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.DescribeTableResponse.table)
  if (response_case() == kTable) {
    clear_has_response();
    ::fivetran_sdk::Table* temp = _impl_.response_.table_;
    _impl_.response_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DescribeTableResponse::unsafe_arena_set_allocated_table(::fivetran_sdk::Table* table) {
  clear_response();
  if (table) {
    set_has_table();
    _impl_.response_.table_ = table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.DescribeTableResponse.table)
}
inline ::fivetran_sdk::Table* DescribeTableResponse::_internal_mutable_table() {
  if (response_case() != kTable) {
    clear_response();
    set_has_table();
    _impl_.response_.table_ = CreateMaybeMessage< ::fivetran_sdk::Table >(GetArenaForAllocation());
  }
  return _impl_.response_.table_;
}
inline ::fivetran_sdk::Table* DescribeTableResponse::mutable_table() {
  ::fivetran_sdk::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.DescribeTableResponse.table)
  return _msg;
}

inline bool DescribeTableResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void DescribeTableResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline DescribeTableResponse::ResponseCase DescribeTableResponse::response_case() const {
  return DescribeTableResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateTableRequest

// map<string, string> configuration = 1;
inline int CreateTableRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int CreateTableRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void CreateTableRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.CreateTableRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.CreateTableRequest.configuration)
  return _internal_mutable_configuration();
}

// string schema_name = 2;
inline void CreateTableRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CreateTableRequest.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTableRequest::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.CreateTableRequest.schema_name)
}
inline std::string* CreateTableRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.CreateTableRequest.schema_name)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateTableRequest::_internal_set_schema_name(const std::string& value) {
  ;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableRequest::_internal_mutable_schema_name() {
  ;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateTableRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.CreateTableRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateTableRequest::set_allocated_schema_name(std::string* value) {
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.CreateTableRequest.schema_name)
}

// .fivetran_sdk.Table table = 3;
inline bool CreateTableRequest::has_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_ != nullptr);
  return value;
}
inline const ::fivetran_sdk::Table& CreateTableRequest::_internal_table() const {
  const ::fivetran_sdk::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::fivetran_sdk::Table&>(
      ::fivetran_sdk::_Table_default_instance_);
}
inline const ::fivetran_sdk::Table& CreateTableRequest::table() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CreateTableRequest.table)
  return _internal_table();
}
inline void CreateTableRequest::unsafe_arena_set_allocated_table(
    ::fivetran_sdk::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.CreateTableRequest.table)
}
inline ::fivetran_sdk::Table* CreateTableRequest::release_table() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fivetran_sdk::Table* CreateTableRequest::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.CreateTableRequest.table)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::fivetran_sdk::Table* CreateTableRequest::_internal_mutable_table() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::fivetran_sdk::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::fivetran_sdk::Table* CreateTableRequest::mutable_table() {
  ::fivetran_sdk::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.CreateTableRequest.table)
  return _msg;
}
inline void CreateTableRequest::set_allocated_table(::fivetran_sdk::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table));
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.CreateTableRequest.table)
}

// -------------------------------------------------------------------

// CreateTableResponse

// bool success = 1;
inline bool CreateTableResponse::has_success() const {
  return response_case() == kSuccess;
}
inline void CreateTableResponse::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void CreateTableResponse::clear_success() {
  if (response_case() == kSuccess) {
    _impl_.response_.success_ = false;
    clear_has_response();
  }
}
inline bool CreateTableResponse::success() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CreateTableResponse.success)
  return _internal_success();
}
inline void CreateTableResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.CreateTableResponse.success)
}
inline bool CreateTableResponse::_internal_success() const {
  if (response_case() == kSuccess) {
    return _impl_.response_.success_;
  }
  return false;
}
inline void CreateTableResponse::_internal_set_success(bool value) {
  if (response_case() != kSuccess) {
    clear_response();
    set_has_success();
  }
  _impl_.response_.success_ = value;
}

// string failure = 2;
inline bool CreateTableResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void CreateTableResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void CreateTableResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& CreateTableResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CreateTableResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTableResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.CreateTableResponse.failure)
}
inline std::string* CreateTableResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.CreateTableResponse.failure)
  return _s;
}
inline const std::string& CreateTableResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void CreateTableResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateTableResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.CreateTableResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void CreateTableResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.CreateTableResponse.failure)
}

inline bool CreateTableResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void CreateTableResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline CreateTableResponse::ResponseCase CreateTableResponse::response_case() const {
  return CreateTableResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AlterTableRequest

// map<string, string> configuration = 1;
inline int AlterTableRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int AlterTableRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void AlterTableRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AlterTableRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AlterTableRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.AlterTableRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AlterTableRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AlterTableRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.AlterTableRequest.configuration)
  return _internal_mutable_configuration();
}

// string schema_name = 2;
inline void AlterTableRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& AlterTableRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.AlterTableRequest.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlterTableRequest::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.AlterTableRequest.schema_name)
}
inline std::string* AlterTableRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.AlterTableRequest.schema_name)
  return _s;
}
inline const std::string& AlterTableRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void AlterTableRequest::_internal_set_schema_name(const std::string& value) {
  ;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::_internal_mutable_schema_name() {
  ;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AlterTableRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.AlterTableRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void AlterTableRequest::set_allocated_schema_name(std::string* value) {
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.AlterTableRequest.schema_name)
}

// .fivetran_sdk.Table table = 3;
inline bool AlterTableRequest::has_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_ != nullptr);
  return value;
}
inline const ::fivetran_sdk::Table& AlterTableRequest::_internal_table() const {
  const ::fivetran_sdk::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::fivetran_sdk::Table&>(
      ::fivetran_sdk::_Table_default_instance_);
}
inline const ::fivetran_sdk::Table& AlterTableRequest::table() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.AlterTableRequest.table)
  return _internal_table();
}
inline void AlterTableRequest::unsafe_arena_set_allocated_table(
    ::fivetran_sdk::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.AlterTableRequest.table)
}
inline ::fivetran_sdk::Table* AlterTableRequest::release_table() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fivetran_sdk::Table* AlterTableRequest::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.AlterTableRequest.table)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::fivetran_sdk::Table* AlterTableRequest::_internal_mutable_table() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::fivetran_sdk::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::fivetran_sdk::Table* AlterTableRequest::mutable_table() {
  ::fivetran_sdk::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.AlterTableRequest.table)
  return _msg;
}
inline void AlterTableRequest::set_allocated_table(::fivetran_sdk::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table));
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.AlterTableRequest.table)
}

// -------------------------------------------------------------------

// AlterTableResponse

// bool success = 1;
inline bool AlterTableResponse::has_success() const {
  return response_case() == kSuccess;
}
inline void AlterTableResponse::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void AlterTableResponse::clear_success() {
  if (response_case() == kSuccess) {
    _impl_.response_.success_ = false;
    clear_has_response();
  }
}
inline bool AlterTableResponse::success() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.AlterTableResponse.success)
  return _internal_success();
}
inline void AlterTableResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.AlterTableResponse.success)
}
inline bool AlterTableResponse::_internal_success() const {
  if (response_case() == kSuccess) {
    return _impl_.response_.success_;
  }
  return false;
}
inline void AlterTableResponse::_internal_set_success(bool value) {
  if (response_case() != kSuccess) {
    clear_response();
    set_has_success();
  }
  _impl_.response_.success_ = value;
}

// string failure = 2;
inline bool AlterTableResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void AlterTableResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void AlterTableResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& AlterTableResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.AlterTableResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlterTableResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.AlterTableResponse.failure)
}
inline std::string* AlterTableResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.AlterTableResponse.failure)
  return _s;
}
inline const std::string& AlterTableResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void AlterTableResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterTableResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* AlterTableResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.AlterTableResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void AlterTableResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.AlterTableResponse.failure)
}

inline bool AlterTableResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void AlterTableResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline AlterTableResponse::ResponseCase AlterTableResponse::response_case() const {
  return AlterTableResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TruncateRequest

// map<string, string> configuration = 1;
inline int TruncateRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int TruncateRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void TruncateRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TruncateRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TruncateRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.TruncateRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TruncateRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TruncateRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.TruncateRequest.configuration)
  return _internal_mutable_configuration();
}

// string schema_name = 2;
inline void TruncateRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TruncateRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateRequest.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TruncateRequest::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TruncateRequest.schema_name)
}
inline std::string* TruncateRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateRequest.schema_name)
  return _s;
}
inline const std::string& TruncateRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TruncateRequest::_internal_set_schema_name(const std::string& value) {
  ;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateRequest::_internal_mutable_schema_name() {
  ;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* TruncateRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TruncateRequest::set_allocated_schema_name(std::string* value) {
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateRequest.schema_name)
}

// string table_name = 3;
inline void TruncateRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TruncateRequest::table_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateRequest.table_name)
  return _internal_table_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TruncateRequest::set_table_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.table_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TruncateRequest.table_name)
}
inline std::string* TruncateRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateRequest.table_name)
  return _s;
}
inline const std::string& TruncateRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TruncateRequest::_internal_set_table_name(const std::string& value) {
  ;


  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateRequest::_internal_mutable_table_name() {
  ;
  return _impl_.table_name_.Mutable( GetArenaForAllocation());
}
inline std::string* TruncateRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void TruncateRequest::set_allocated_table_name(std::string* value) {
  _impl_.table_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_name_.IsDefault()) {
          _impl_.table_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateRequest.table_name)
}

// string synced_column = 4;
inline void TruncateRequest::clear_synced_column() {
  _impl_.synced_column_.ClearToEmpty();
}
inline const std::string& TruncateRequest::synced_column() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateRequest.synced_column)
  return _internal_synced_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TruncateRequest::set_synced_column(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.synced_column_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TruncateRequest.synced_column)
}
inline std::string* TruncateRequest::mutable_synced_column() {
  std::string* _s = _internal_mutable_synced_column();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateRequest.synced_column)
  return _s;
}
inline const std::string& TruncateRequest::_internal_synced_column() const {
  return _impl_.synced_column_.Get();
}
inline void TruncateRequest::_internal_set_synced_column(const std::string& value) {
  ;


  _impl_.synced_column_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateRequest::_internal_mutable_synced_column() {
  ;
  return _impl_.synced_column_.Mutable( GetArenaForAllocation());
}
inline std::string* TruncateRequest::release_synced_column() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateRequest.synced_column)
  return _impl_.synced_column_.Release();
}
inline void TruncateRequest::set_allocated_synced_column(std::string* value) {
  _impl_.synced_column_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.synced_column_.IsDefault()) {
          _impl_.synced_column_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateRequest.synced_column)
}

// .google.protobuf.Timestamp utc_delete_before = 5;
inline bool TruncateRequest::has_utc_delete_before() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.utc_delete_before_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TruncateRequest::_internal_utc_delete_before() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.utc_delete_before_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TruncateRequest::utc_delete_before() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateRequest.utc_delete_before)
  return _internal_utc_delete_before();
}
inline void TruncateRequest::unsafe_arena_set_allocated_utc_delete_before(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* utc_delete_before) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.utc_delete_before_);
  }
  _impl_.utc_delete_before_ = utc_delete_before;
  if (utc_delete_before) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.TruncateRequest.utc_delete_before)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TruncateRequest::release_utc_delete_before() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.utc_delete_before_;
  _impl_.utc_delete_before_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TruncateRequest::unsafe_arena_release_utc_delete_before() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateRequest.utc_delete_before)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.utc_delete_before_;
  _impl_.utc_delete_before_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TruncateRequest::_internal_mutable_utc_delete_before() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.utc_delete_before_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.utc_delete_before_ = p;
  }
  return _impl_.utc_delete_before_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TruncateRequest::mutable_utc_delete_before() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_utc_delete_before();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateRequest.utc_delete_before)
  return _msg;
}
inline void TruncateRequest::set_allocated_utc_delete_before(::PROTOBUF_NAMESPACE_ID::Timestamp* utc_delete_before) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.utc_delete_before_);
  }
  if (utc_delete_before) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(utc_delete_before));
    if (message_arena != submessage_arena) {
      utc_delete_before = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, utc_delete_before, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.utc_delete_before_ = utc_delete_before;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateRequest.utc_delete_before)
}

// optional .fivetran_sdk.SoftTruncate soft = 6;
inline bool TruncateRequest::has_soft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.soft_ != nullptr);
  return value;
}
inline void TruncateRequest::clear_soft() {
  if (_impl_.soft_ != nullptr) _impl_.soft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::fivetran_sdk::SoftTruncate& TruncateRequest::_internal_soft() const {
  const ::fivetran_sdk::SoftTruncate* p = _impl_.soft_;
  return p != nullptr ? *p : reinterpret_cast<const ::fivetran_sdk::SoftTruncate&>(
      ::fivetran_sdk::_SoftTruncate_default_instance_);
}
inline const ::fivetran_sdk::SoftTruncate& TruncateRequest::soft() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateRequest.soft)
  return _internal_soft();
}
inline void TruncateRequest::unsafe_arena_set_allocated_soft(
    ::fivetran_sdk::SoftTruncate* soft) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soft_);
  }
  _impl_.soft_ = soft;
  if (soft) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.TruncateRequest.soft)
}
inline ::fivetran_sdk::SoftTruncate* TruncateRequest::release_soft() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::fivetran_sdk::SoftTruncate* temp = _impl_.soft_;
  _impl_.soft_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fivetran_sdk::SoftTruncate* TruncateRequest::unsafe_arena_release_soft() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateRequest.soft)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::fivetran_sdk::SoftTruncate* temp = _impl_.soft_;
  _impl_.soft_ = nullptr;
  return temp;
}
inline ::fivetran_sdk::SoftTruncate* TruncateRequest::_internal_mutable_soft() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.soft_ == nullptr) {
    auto* p = CreateMaybeMessage<::fivetran_sdk::SoftTruncate>(GetArenaForAllocation());
    _impl_.soft_ = p;
  }
  return _impl_.soft_;
}
inline ::fivetran_sdk::SoftTruncate* TruncateRequest::mutable_soft() {
  ::fivetran_sdk::SoftTruncate* _msg = _internal_mutable_soft();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateRequest.soft)
  return _msg;
}
inline void TruncateRequest::set_allocated_soft(::fivetran_sdk::SoftTruncate* soft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.soft_;
  }
  if (soft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(soft);
    if (message_arena != submessage_arena) {
      soft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soft, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.soft_ = soft;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateRequest.soft)
}

// -------------------------------------------------------------------

// SoftTruncate

// string deleted_column = 3;
inline void SoftTruncate::clear_deleted_column() {
  _impl_.deleted_column_.ClearToEmpty();
}
inline const std::string& SoftTruncate::deleted_column() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.SoftTruncate.deleted_column)
  return _internal_deleted_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoftTruncate::set_deleted_column(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.deleted_column_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.SoftTruncate.deleted_column)
}
inline std::string* SoftTruncate::mutable_deleted_column() {
  std::string* _s = _internal_mutable_deleted_column();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.SoftTruncate.deleted_column)
  return _s;
}
inline const std::string& SoftTruncate::_internal_deleted_column() const {
  return _impl_.deleted_column_.Get();
}
inline void SoftTruncate::_internal_set_deleted_column(const std::string& value) {
  ;


  _impl_.deleted_column_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftTruncate::_internal_mutable_deleted_column() {
  ;
  return _impl_.deleted_column_.Mutable( GetArenaForAllocation());
}
inline std::string* SoftTruncate::release_deleted_column() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.SoftTruncate.deleted_column)
  return _impl_.deleted_column_.Release();
}
inline void SoftTruncate::set_allocated_deleted_column(std::string* value) {
  _impl_.deleted_column_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deleted_column_.IsDefault()) {
          _impl_.deleted_column_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.SoftTruncate.deleted_column)
}

// -------------------------------------------------------------------

// TruncateResponse

// bool success = 1;
inline bool TruncateResponse::has_success() const {
  return response_case() == kSuccess;
}
inline void TruncateResponse::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void TruncateResponse::clear_success() {
  if (response_case() == kSuccess) {
    _impl_.response_.success_ = false;
    clear_has_response();
  }
}
inline bool TruncateResponse::success() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateResponse.success)
  return _internal_success();
}
inline void TruncateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.TruncateResponse.success)
}
inline bool TruncateResponse::_internal_success() const {
  if (response_case() == kSuccess) {
    return _impl_.response_.success_;
  }
  return false;
}
inline void TruncateResponse::_internal_set_success(bool value) {
  if (response_case() != kSuccess) {
    clear_response();
    set_has_success();
  }
  _impl_.response_.success_ = value;
}

// string failure = 2;
inline bool TruncateResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void TruncateResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void TruncateResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& TruncateResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TruncateResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TruncateResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TruncateResponse.failure)
}
inline std::string* TruncateResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TruncateResponse.failure)
  return _s;
}
inline const std::string& TruncateResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void TruncateResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* TruncateResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TruncateResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void TruncateResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TruncateResponse.failure)
}

inline bool TruncateResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void TruncateResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline TruncateResponse::ResponseCase TruncateResponse::response_case() const {
  return TruncateResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WriteBatchRequest

// map<string, string> configuration = 1;
inline int WriteBatchRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int WriteBatchRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void WriteBatchRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteBatchRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteBatchRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.WriteBatchRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteBatchRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteBatchRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.WriteBatchRequest.configuration)
  return _internal_mutable_configuration();
}

// string schema_name = 2;
inline void WriteBatchRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& WriteBatchRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WriteBatchRequest::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.schema_name)
}
inline std::string* WriteBatchRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.schema_name)
  return _s;
}
inline const std::string& WriteBatchRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void WriteBatchRequest::_internal_set_schema_name(const std::string& value) {
  ;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteBatchRequest::_internal_mutable_schema_name() {
  ;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WriteBatchRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.WriteBatchRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void WriteBatchRequest::set_allocated_schema_name(std::string* value) {
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.WriteBatchRequest.schema_name)
}

// .fivetran_sdk.Table table = 3;
inline bool WriteBatchRequest::has_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_ != nullptr);
  return value;
}
inline const ::fivetran_sdk::Table& WriteBatchRequest::_internal_table() const {
  const ::fivetran_sdk::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::fivetran_sdk::Table&>(
      ::fivetran_sdk::_Table_default_instance_);
}
inline const ::fivetran_sdk::Table& WriteBatchRequest::table() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.table)
  return _internal_table();
}
inline void WriteBatchRequest::unsafe_arena_set_allocated_table(
    ::fivetran_sdk::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.WriteBatchRequest.table)
}
inline ::fivetran_sdk::Table* WriteBatchRequest::release_table() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fivetran_sdk::Table* WriteBatchRequest::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.WriteBatchRequest.table)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::fivetran_sdk::Table* WriteBatchRequest::_internal_mutable_table() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::fivetran_sdk::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::fivetran_sdk::Table* WriteBatchRequest::mutable_table() {
  ::fivetran_sdk::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.table)
  return _msg;
}
inline void WriteBatchRequest::set_allocated_table(::fivetran_sdk::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table));
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.WriteBatchRequest.table)
}

// map<string, bytes> keys = 4;
inline int WriteBatchRequest::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int WriteBatchRequest::keys_size() const {
  return _internal_keys_size();
}
inline void WriteBatchRequest::clear_keys() {
  _impl_.keys_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteBatchRequest::_internal_keys() const {
  return _impl_.keys_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteBatchRequest::keys() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.WriteBatchRequest.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteBatchRequest::_internal_mutable_keys() {
  return _impl_.keys_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteBatchRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.WriteBatchRequest.keys)
  return _internal_mutable_keys();
}

// repeated string replace_files = 5;
inline int WriteBatchRequest::_internal_replace_files_size() const {
  return _impl_.replace_files_.size();
}
inline int WriteBatchRequest::replace_files_size() const {
  return _internal_replace_files_size();
}
inline void WriteBatchRequest::clear_replace_files() {
  _internal_mutable_replace_files()->Clear();
}
inline std::string* WriteBatchRequest::add_replace_files() {
  std::string* _s = _internal_add_replace_files();
  // @@protoc_insertion_point(field_add_mutable:fivetran_sdk.WriteBatchRequest.replace_files)
  return _s;
}
inline const std::string& WriteBatchRequest::replace_files(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.replace_files)
  return _internal_replace_files(index);
}
inline std::string* WriteBatchRequest::mutable_replace_files(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.replace_files)
  return _internal_mutable_replace_files()->Mutable(index);
}
inline void WriteBatchRequest::set_replace_files(int index, const std::string& value) {
  _internal_mutable_replace_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::set_replace_files(int index, std::string&& value) {
  _internal_mutable_replace_files()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::set_replace_files(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_replace_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::set_replace_files(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_replace_files()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::set_replace_files(int index, absl::string_view value) {
  _internal_mutable_replace_files()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::add_replace_files(const std::string& value) {
  _internal_mutable_replace_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::add_replace_files(std::string&& value) {
  _internal_mutable_replace_files()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::add_replace_files(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_replace_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::add_replace_files(const char* value, std::size_t size) {
  _internal_mutable_replace_files()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline void WriteBatchRequest::add_replace_files(absl::string_view value) {
  _internal_mutable_replace_files()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:fivetran_sdk.WriteBatchRequest.replace_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::replace_files() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.WriteBatchRequest.replace_files)
  return _internal_replace_files();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* WriteBatchRequest::mutable_replace_files() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.WriteBatchRequest.replace_files)
  return _internal_mutable_replace_files();
}
inline const std::string& WriteBatchRequest::_internal_replace_files(int index) const {
  return _internal_replace_files().Get(index);
}
inline std::string* WriteBatchRequest::_internal_add_replace_files() {
  return _internal_mutable_replace_files()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::_internal_replace_files() const {
  return _impl_.replace_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WriteBatchRequest::_internal_mutable_replace_files() {
  return &_impl_.replace_files_;
}

// repeated string update_files = 6;
inline int WriteBatchRequest::_internal_update_files_size() const {
  return _impl_.update_files_.size();
}
inline int WriteBatchRequest::update_files_size() const {
  return _internal_update_files_size();
}
inline void WriteBatchRequest::clear_update_files() {
  _internal_mutable_update_files()->Clear();
}
inline std::string* WriteBatchRequest::add_update_files() {
  std::string* _s = _internal_add_update_files();
  // @@protoc_insertion_point(field_add_mutable:fivetran_sdk.WriteBatchRequest.update_files)
  return _s;
}
inline const std::string& WriteBatchRequest::update_files(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.update_files)
  return _internal_update_files(index);
}
inline std::string* WriteBatchRequest::mutable_update_files(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.update_files)
  return _internal_mutable_update_files()->Mutable(index);
}
inline void WriteBatchRequest::set_update_files(int index, const std::string& value) {
  _internal_mutable_update_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::set_update_files(int index, std::string&& value) {
  _internal_mutable_update_files()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::set_update_files(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_update_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::set_update_files(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_update_files()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::set_update_files(int index, absl::string_view value) {
  _internal_mutable_update_files()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::add_update_files(const std::string& value) {
  _internal_mutable_update_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::add_update_files(std::string&& value) {
  _internal_mutable_update_files()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::add_update_files(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_update_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::add_update_files(const char* value, std::size_t size) {
  _internal_mutable_update_files()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fivetran_sdk.WriteBatchRequest.update_files)
}
inline void WriteBatchRequest::add_update_files(absl::string_view value) {
  _internal_mutable_update_files()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:fivetran_sdk.WriteBatchRequest.update_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::update_files() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.WriteBatchRequest.update_files)
  return _internal_update_files();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* WriteBatchRequest::mutable_update_files() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.WriteBatchRequest.update_files)
  return _internal_mutable_update_files();
}
inline const std::string& WriteBatchRequest::_internal_update_files(int index) const {
  return _internal_update_files().Get(index);
}
inline std::string* WriteBatchRequest::_internal_add_update_files() {
  return _internal_mutable_update_files()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::_internal_update_files() const {
  return _impl_.update_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WriteBatchRequest::_internal_mutable_update_files() {
  return &_impl_.update_files_;
}

// repeated string delete_files = 7;
inline int WriteBatchRequest::_internal_delete_files_size() const {
  return _impl_.delete_files_.size();
}
inline int WriteBatchRequest::delete_files_size() const {
  return _internal_delete_files_size();
}
inline void WriteBatchRequest::clear_delete_files() {
  _internal_mutable_delete_files()->Clear();
}
inline std::string* WriteBatchRequest::add_delete_files() {
  std::string* _s = _internal_add_delete_files();
  // @@protoc_insertion_point(field_add_mutable:fivetran_sdk.WriteBatchRequest.delete_files)
  return _s;
}
inline const std::string& WriteBatchRequest::delete_files(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.delete_files)
  return _internal_delete_files(index);
}
inline std::string* WriteBatchRequest::mutable_delete_files(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.delete_files)
  return _internal_mutable_delete_files()->Mutable(index);
}
inline void WriteBatchRequest::set_delete_files(int index, const std::string& value) {
  _internal_mutable_delete_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::set_delete_files(int index, std::string&& value) {
  _internal_mutable_delete_files()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::set_delete_files(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_delete_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::set_delete_files(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_delete_files()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::set_delete_files(int index, absl::string_view value) {
  _internal_mutable_delete_files()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::add_delete_files(const std::string& value) {
  _internal_mutable_delete_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::add_delete_files(std::string&& value) {
  _internal_mutable_delete_files()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::add_delete_files(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_delete_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::add_delete_files(const char* value, std::size_t size) {
  _internal_mutable_delete_files()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline void WriteBatchRequest::add_delete_files(absl::string_view value) {
  _internal_mutable_delete_files()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:fivetran_sdk.WriteBatchRequest.delete_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::delete_files() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.WriteBatchRequest.delete_files)
  return _internal_delete_files();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* WriteBatchRequest::mutable_delete_files() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.WriteBatchRequest.delete_files)
  return _internal_mutable_delete_files();
}
inline const std::string& WriteBatchRequest::_internal_delete_files(int index) const {
  return _internal_delete_files().Get(index);
}
inline std::string* WriteBatchRequest::_internal_add_delete_files() {
  return _internal_mutable_delete_files()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteBatchRequest::_internal_delete_files() const {
  return _impl_.delete_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WriteBatchRequest::_internal_mutable_delete_files() {
  return &_impl_.delete_files_;
}

// .fivetran_sdk.CsvFileParams csv = 8;
inline bool WriteBatchRequest::has_csv() const {
  return file_params_case() == kCsv;
}
inline bool WriteBatchRequest::_internal_has_csv() const {
  return file_params_case() == kCsv;
}
inline void WriteBatchRequest::set_has_csv() {
  _impl_._oneof_case_[0] = kCsv;
}
inline void WriteBatchRequest::clear_csv() {
  if (file_params_case() == kCsv) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.file_params_.csv_;
    }
    clear_has_file_params();
  }
}
inline ::fivetran_sdk::CsvFileParams* WriteBatchRequest::release_csv() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.WriteBatchRequest.csv)
  if (file_params_case() == kCsv) {
    clear_has_file_params();
    ::fivetran_sdk::CsvFileParams* temp = _impl_.file_params_.csv_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_params_.csv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fivetran_sdk::CsvFileParams& WriteBatchRequest::_internal_csv() const {
  return file_params_case() == kCsv
      ? *_impl_.file_params_.csv_
      : reinterpret_cast<::fivetran_sdk::CsvFileParams&>(::fivetran_sdk::_CsvFileParams_default_instance_);
}
inline const ::fivetran_sdk::CsvFileParams& WriteBatchRequest::csv() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchRequest.csv)
  return _internal_csv();
}
inline ::fivetran_sdk::CsvFileParams* WriteBatchRequest::unsafe_arena_release_csv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.WriteBatchRequest.csv)
  if (file_params_case() == kCsv) {
    clear_has_file_params();
    ::fivetran_sdk::CsvFileParams* temp = _impl_.file_params_.csv_;
    _impl_.file_params_.csv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WriteBatchRequest::unsafe_arena_set_allocated_csv(::fivetran_sdk::CsvFileParams* csv) {
  clear_file_params();
  if (csv) {
    set_has_csv();
    _impl_.file_params_.csv_ = csv;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.WriteBatchRequest.csv)
}
inline ::fivetran_sdk::CsvFileParams* WriteBatchRequest::_internal_mutable_csv() {
  if (file_params_case() != kCsv) {
    clear_file_params();
    set_has_csv();
    _impl_.file_params_.csv_ = CreateMaybeMessage< ::fivetran_sdk::CsvFileParams >(GetArenaForAllocation());
  }
  return _impl_.file_params_.csv_;
}
inline ::fivetran_sdk::CsvFileParams* WriteBatchRequest::mutable_csv() {
  ::fivetran_sdk::CsvFileParams* _msg = _internal_mutable_csv();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchRequest.csv)
  return _msg;
}

inline bool WriteBatchRequest::has_file_params() const {
  return file_params_case() != FILE_PARAMS_NOT_SET;
}
inline void WriteBatchRequest::clear_has_file_params() {
  _impl_._oneof_case_[0] = FILE_PARAMS_NOT_SET;
}
inline WriteBatchRequest::FileParamsCase WriteBatchRequest::file_params_case() const {
  return WriteBatchRequest::FileParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CsvFileParams

// .fivetran_sdk.Compression compression = 1;
inline void CsvFileParams::clear_compression() {
  _impl_.compression_ = 0;
}
inline ::fivetran_sdk::Compression CsvFileParams::compression() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CsvFileParams.compression)
  return _internal_compression();
}
inline void CsvFileParams::set_compression(::fivetran_sdk::Compression value) {
   _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.CsvFileParams.compression)
}
inline ::fivetran_sdk::Compression CsvFileParams::_internal_compression() const {
  return static_cast<::fivetran_sdk::Compression>(_impl_.compression_);
}
inline void CsvFileParams::_internal_set_compression(::fivetran_sdk::Compression value) {
  ;
  _impl_.compression_ = value;
}

// .fivetran_sdk.Encryption encryption = 2;
inline void CsvFileParams::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::fivetran_sdk::Encryption CsvFileParams::encryption() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CsvFileParams.encryption)
  return _internal_encryption();
}
inline void CsvFileParams::set_encryption(::fivetran_sdk::Encryption value) {
   _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.CsvFileParams.encryption)
}
inline ::fivetran_sdk::Encryption CsvFileParams::_internal_encryption() const {
  return static_cast<::fivetran_sdk::Encryption>(_impl_.encryption_);
}
inline void CsvFileParams::_internal_set_encryption(::fivetran_sdk::Encryption value) {
  ;
  _impl_.encryption_ = value;
}

// string null_string = 3;
inline void CsvFileParams::clear_null_string() {
  _impl_.null_string_.ClearToEmpty();
}
inline const std::string& CsvFileParams::null_string() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CsvFileParams.null_string)
  return _internal_null_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CsvFileParams::set_null_string(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.null_string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.CsvFileParams.null_string)
}
inline std::string* CsvFileParams::mutable_null_string() {
  std::string* _s = _internal_mutable_null_string();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.CsvFileParams.null_string)
  return _s;
}
inline const std::string& CsvFileParams::_internal_null_string() const {
  return _impl_.null_string_.Get();
}
inline void CsvFileParams::_internal_set_null_string(const std::string& value) {
  ;


  _impl_.null_string_.Set(value, GetArenaForAllocation());
}
inline std::string* CsvFileParams::_internal_mutable_null_string() {
  ;
  return _impl_.null_string_.Mutable( GetArenaForAllocation());
}
inline std::string* CsvFileParams::release_null_string() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.CsvFileParams.null_string)
  return _impl_.null_string_.Release();
}
inline void CsvFileParams::set_allocated_null_string(std::string* value) {
  _impl_.null_string_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.null_string_.IsDefault()) {
          _impl_.null_string_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.CsvFileParams.null_string)
}

// string unmodified_string = 4;
inline void CsvFileParams::clear_unmodified_string() {
  _impl_.unmodified_string_.ClearToEmpty();
}
inline const std::string& CsvFileParams::unmodified_string() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.CsvFileParams.unmodified_string)
  return _internal_unmodified_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CsvFileParams::set_unmodified_string(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unmodified_string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.CsvFileParams.unmodified_string)
}
inline std::string* CsvFileParams::mutable_unmodified_string() {
  std::string* _s = _internal_mutable_unmodified_string();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.CsvFileParams.unmodified_string)
  return _s;
}
inline const std::string& CsvFileParams::_internal_unmodified_string() const {
  return _impl_.unmodified_string_.Get();
}
inline void CsvFileParams::_internal_set_unmodified_string(const std::string& value) {
  ;


  _impl_.unmodified_string_.Set(value, GetArenaForAllocation());
}
inline std::string* CsvFileParams::_internal_mutable_unmodified_string() {
  ;
  return _impl_.unmodified_string_.Mutable( GetArenaForAllocation());
}
inline std::string* CsvFileParams::release_unmodified_string() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.CsvFileParams.unmodified_string)
  return _impl_.unmodified_string_.Release();
}
inline void CsvFileParams::set_allocated_unmodified_string(std::string* value) {
  _impl_.unmodified_string_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unmodified_string_.IsDefault()) {
          _impl_.unmodified_string_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.CsvFileParams.unmodified_string)
}

// -------------------------------------------------------------------

// WriteBatchResponse

// bool success = 1;
inline bool WriteBatchResponse::has_success() const {
  return response_case() == kSuccess;
}
inline void WriteBatchResponse::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void WriteBatchResponse::clear_success() {
  if (response_case() == kSuccess) {
    _impl_.response_.success_ = false;
    clear_has_response();
  }
}
inline bool WriteBatchResponse::success() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchResponse.success)
  return _internal_success();
}
inline void WriteBatchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchResponse.success)
}
inline bool WriteBatchResponse::_internal_success() const {
  if (response_case() == kSuccess) {
    return _impl_.response_.success_;
  }
  return false;
}
inline void WriteBatchResponse::_internal_set_success(bool value) {
  if (response_case() != kSuccess) {
    clear_response();
    set_has_success();
  }
  _impl_.response_.success_ = value;
}

// string failure = 2;
inline bool WriteBatchResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void WriteBatchResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void WriteBatchResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& WriteBatchResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.WriteBatchResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WriteBatchResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.WriteBatchResponse.failure)
}
inline std::string* WriteBatchResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.WriteBatchResponse.failure)
  return _s;
}
inline const std::string& WriteBatchResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void WriteBatchResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteBatchResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* WriteBatchResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.WriteBatchResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void WriteBatchResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.WriteBatchResponse.failure)
}

inline bool WriteBatchResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void WriteBatchResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline WriteBatchResponse::ResponseCase WriteBatchResponse::response_case() const {
  return WriteBatchResponse::ResponseCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace fivetran_sdk


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::fivetran_sdk::Encryption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::fivetran_sdk::Encryption>() {
  return ::fivetran_sdk::Encryption_descriptor();
}
template <>
struct is_proto_enum<::fivetran_sdk::Compression> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::fivetran_sdk::Compression>() {
  return ::fivetran_sdk::Compression_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_destination_5fsdk_2eproto_2epb_2eh
