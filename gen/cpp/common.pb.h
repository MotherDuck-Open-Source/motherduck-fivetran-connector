// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_common_2eproto;
namespace fivetran_sdk {
class Column;
struct ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class ConfigurationFormRequest;
struct ConfigurationFormRequestDefaultTypeInternal;
extern ConfigurationFormRequestDefaultTypeInternal _ConfigurationFormRequest_default_instance_;
class ConfigurationFormResponse;
struct ConfigurationFormResponseDefaultTypeInternal;
extern ConfigurationFormResponseDefaultTypeInternal _ConfigurationFormResponse_default_instance_;
class ConfigurationTest;
struct ConfigurationTestDefaultTypeInternal;
extern ConfigurationTestDefaultTypeInternal _ConfigurationTest_default_instance_;
class DecimalParams;
struct DecimalParamsDefaultTypeInternal;
extern DecimalParamsDefaultTypeInternal _DecimalParams_default_instance_;
class DropdownField;
struct DropdownFieldDefaultTypeInternal;
extern DropdownFieldDefaultTypeInternal _DropdownField_default_instance_;
class FormField;
struct FormFieldDefaultTypeInternal;
extern FormFieldDefaultTypeInternal _FormField_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaList;
struct SchemaListDefaultTypeInternal;
extern SchemaListDefaultTypeInternal _SchemaList_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableList;
struct TableListDefaultTypeInternal;
extern TableListDefaultTypeInternal _TableList_default_instance_;
class TestRequest;
struct TestRequestDefaultTypeInternal;
extern TestRequestDefaultTypeInternal _TestRequest_default_instance_;
class TestRequest_ConfigurationEntry_DoNotUse;
struct TestRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern TestRequest_ConfigurationEntry_DoNotUseDefaultTypeInternal _TestRequest_ConfigurationEntry_DoNotUse_default_instance_;
class TestResponse;
struct TestResponseDefaultTypeInternal;
extern TestResponseDefaultTypeInternal _TestResponse_default_instance_;
class ToggleField;
struct ToggleFieldDefaultTypeInternal;
extern ToggleFieldDefaultTypeInternal _ToggleField_default_instance_;
class ValueType;
struct ValueTypeDefaultTypeInternal;
extern ValueTypeDefaultTypeInternal _ValueType_default_instance_;
}  // namespace fivetran_sdk
PROTOBUF_NAMESPACE_OPEN
template <>
::fivetran_sdk::Column* Arena::CreateMaybeMessage<::fivetran_sdk::Column>(Arena*);
template <>
::fivetran_sdk::ConfigurationFormRequest* Arena::CreateMaybeMessage<::fivetran_sdk::ConfigurationFormRequest>(Arena*);
template <>
::fivetran_sdk::ConfigurationFormResponse* Arena::CreateMaybeMessage<::fivetran_sdk::ConfigurationFormResponse>(Arena*);
template <>
::fivetran_sdk::ConfigurationTest* Arena::CreateMaybeMessage<::fivetran_sdk::ConfigurationTest>(Arena*);
template <>
::fivetran_sdk::DecimalParams* Arena::CreateMaybeMessage<::fivetran_sdk::DecimalParams>(Arena*);
template <>
::fivetran_sdk::DropdownField* Arena::CreateMaybeMessage<::fivetran_sdk::DropdownField>(Arena*);
template <>
::fivetran_sdk::FormField* Arena::CreateMaybeMessage<::fivetran_sdk::FormField>(Arena*);
template <>
::fivetran_sdk::Schema* Arena::CreateMaybeMessage<::fivetran_sdk::Schema>(Arena*);
template <>
::fivetran_sdk::SchemaList* Arena::CreateMaybeMessage<::fivetran_sdk::SchemaList>(Arena*);
template <>
::fivetran_sdk::Table* Arena::CreateMaybeMessage<::fivetran_sdk::Table>(Arena*);
template <>
::fivetran_sdk::TableList* Arena::CreateMaybeMessage<::fivetran_sdk::TableList>(Arena*);
template <>
::fivetran_sdk::TestRequest* Arena::CreateMaybeMessage<::fivetran_sdk::TestRequest>(Arena*);
template <>
::fivetran_sdk::TestRequest_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::fivetran_sdk::TestRequest_ConfigurationEntry_DoNotUse>(Arena*);
template <>
::fivetran_sdk::TestResponse* Arena::CreateMaybeMessage<::fivetran_sdk::TestResponse>(Arena*);
template <>
::fivetran_sdk::ToggleField* Arena::CreateMaybeMessage<::fivetran_sdk::ToggleField>(Arena*);
template <>
::fivetran_sdk::ValueType* Arena::CreateMaybeMessage<::fivetran_sdk::ValueType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace fivetran_sdk {
enum TextField : int {
  PlainText = 0,
  Password = 1,
  Hidden = 2,
  TextField_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TextField_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TextField_IsValid(int value);
constexpr TextField TextField_MIN = static_cast<TextField>(0);
constexpr TextField TextField_MAX = static_cast<TextField>(2);
constexpr int TextField_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TextField_descriptor();
template <typename T>
const std::string& TextField_Name(T value) {
  static_assert(std::is_same<T, TextField>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TextField_Name().");
  return TextField_Name(static_cast<TextField>(value));
}
template <>
inline const std::string& TextField_Name(TextField value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TextField_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TextField_Parse(absl::string_view name, TextField* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextField>(
      TextField_descriptor(), name, value);
}
enum DataType : int {
  UNSPECIFIED = 0,
  BOOLEAN = 1,
  SHORT = 2,
  INT = 3,
  LONG = 4,
  DECIMAL = 5,
  FLOAT = 6,
  DOUBLE = 7,
  NAIVE_DATE = 8,
  NAIVE_DATETIME = 9,
  UTC_DATETIME = 10,
  BINARY = 11,
  XML = 12,
  STRING = 13,
  JSON = 14,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = static_cast<DataType>(0);
constexpr DataType DataType_MAX = static_cast<DataType>(14);
constexpr int DataType_ARRAYSIZE = 14 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DataType_descriptor();
template <typename T>
const std::string& DataType_Name(T value) {
  static_assert(std::is_same<T, DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return DataType_Name(static_cast<DataType>(value));
}
template <>
inline const std::string& DataType_Name(DataType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DataType_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool DataType_Parse(absl::string_view name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
      DataType_descriptor(), name, value);
}
enum OpType : int {
  UPSERT = 0,
  UPDATE = 1,
  DELETE = 2,
  TRUNCATE = 3,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = static_cast<OpType>(0);
constexpr OpType OpType_MAX = static_cast<OpType>(3);
constexpr int OpType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OpType_descriptor();
template <typename T>
const std::string& OpType_Name(T value) {
  static_assert(std::is_same<T, OpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OpType_Name().");
  return OpType_Name(static_cast<OpType>(value));
}
template <>
inline const std::string& OpType_Name(OpType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OpType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool OpType_Parse(absl::string_view name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
      OpType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ConfigurationFormRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:fivetran_sdk.ConfigurationFormRequest) */ {
 public:
  inline ConfigurationFormRequest() : ConfigurationFormRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigurationFormRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationFormRequest(const ConfigurationFormRequest& from);
  ConfigurationFormRequest(ConfigurationFormRequest&& from) noexcept
    : ConfigurationFormRequest() {
    *this = ::std::move(from);
  }

  inline ConfigurationFormRequest& operator=(const ConfigurationFormRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationFormRequest& operator=(ConfigurationFormRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigurationFormRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationFormRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigurationFormRequest*>(
               &_ConfigurationFormRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConfigurationFormRequest& a, ConfigurationFormRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationFormRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationFormRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationFormRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationFormRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConfigurationFormRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConfigurationFormRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.ConfigurationFormRequest";
  }
  protected:
  explicit ConfigurationFormRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fivetran_sdk.ConfigurationFormRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class ConfigurationFormResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.ConfigurationFormResponse) */ {
 public:
  inline ConfigurationFormResponse() : ConfigurationFormResponse(nullptr) {}
  ~ConfigurationFormResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigurationFormResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationFormResponse(const ConfigurationFormResponse& from);
  ConfigurationFormResponse(ConfigurationFormResponse&& from) noexcept
    : ConfigurationFormResponse() {
    *this = ::std::move(from);
  }

  inline ConfigurationFormResponse& operator=(const ConfigurationFormResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationFormResponse& operator=(ConfigurationFormResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigurationFormResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationFormResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigurationFormResponse*>(
               &_ConfigurationFormResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConfigurationFormResponse& a, ConfigurationFormResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationFormResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationFormResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationFormResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationFormResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigurationFormResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigurationFormResponse& from) {
    ConfigurationFormResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigurationFormResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.ConfigurationFormResponse";
  }
  protected:
  explicit ConfigurationFormResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 3,
    kTestsFieldNumber = 4,
    kSchemaSelectionSupportedFieldNumber = 1,
    kTableSelectionSupportedFieldNumber = 2,
  };
  // repeated .fivetran_sdk.FormField fields = 3;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::fivetran_sdk::FormField* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::FormField >*
      mutable_fields();
  private:
  const ::fivetran_sdk::FormField& _internal_fields(int index) const;
  ::fivetran_sdk::FormField* _internal_add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::FormField>& _internal_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::FormField>* _internal_mutable_fields();
  public:
  const ::fivetran_sdk::FormField& fields(int index) const;
  ::fivetran_sdk::FormField* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::FormField >&
      fields() const;
  // repeated .fivetran_sdk.ConfigurationTest tests = 4;
  int tests_size() const;
  private:
  int _internal_tests_size() const;

  public:
  void clear_tests() ;
  ::fivetran_sdk::ConfigurationTest* mutable_tests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::ConfigurationTest >*
      mutable_tests();
  private:
  const ::fivetran_sdk::ConfigurationTest& _internal_tests(int index) const;
  ::fivetran_sdk::ConfigurationTest* _internal_add_tests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::ConfigurationTest>& _internal_tests() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::ConfigurationTest>* _internal_mutable_tests();
  public:
  const ::fivetran_sdk::ConfigurationTest& tests(int index) const;
  ::fivetran_sdk::ConfigurationTest* add_tests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::ConfigurationTest >&
      tests() const;
  // bool schema_selection_supported = 1;
  void clear_schema_selection_supported() ;
  bool schema_selection_supported() const;
  void set_schema_selection_supported(bool value);

  private:
  bool _internal_schema_selection_supported() const;
  void _internal_set_schema_selection_supported(bool value);

  public:
  // bool table_selection_supported = 2;
  void clear_table_selection_supported() ;
  bool table_selection_supported() const;
  void set_table_selection_supported(bool value);

  private:
  bool _internal_table_selection_supported() const;
  void _internal_set_table_selection_supported(bool value);

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.ConfigurationFormResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::FormField > fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::ConfigurationTest > tests_;
    bool schema_selection_supported_;
    bool table_selection_supported_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class FormField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.FormField) */ {
 public:
  inline FormField() : FormField(nullptr) {}
  ~FormField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FormField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormField(const FormField& from);
  FormField(FormField&& from) noexcept
    : FormField() {
    *this = ::std::move(from);
  }

  inline FormField& operator=(const FormField& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormField& operator=(FormField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormField& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTextField = 5,
    kDropdownField = 6,
    kToggleField = 7,
    TYPE_NOT_SET = 0,
  };

  static inline const FormField* internal_default_instance() {
    return reinterpret_cast<const FormField*>(
               &_FormField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FormField& a, FormField& b) {
    a.Swap(&b);
  }
  inline void Swap(FormField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormField& from) {
    FormField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.FormField";
  }
  protected:
  explicit FormField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLabelFieldNumber = 2,
    kDescriptionFieldNumber = 4,
    kRequiredFieldNumber = 3,
    kTextFieldFieldNumber = 5,
    kDropdownFieldFieldNumber = 6,
    kToggleFieldFieldNumber = 7,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string label = 2;
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // optional string description = 4;
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // bool required = 3;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // .fivetran_sdk.TextField text_field = 5;
  bool has_text_field() const;
  void clear_text_field() ;
  ::fivetran_sdk::TextField text_field() const;
  void set_text_field(::fivetran_sdk::TextField value);

  private:
  ::fivetran_sdk::TextField _internal_text_field() const;
  void _internal_set_text_field(::fivetran_sdk::TextField value);

  public:
  // .fivetran_sdk.DropdownField dropdown_field = 6;
  bool has_dropdown_field() const;
  private:
  bool _internal_has_dropdown_field() const;

  public:
  void clear_dropdown_field() ;
  const ::fivetran_sdk::DropdownField& dropdown_field() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::DropdownField* release_dropdown_field();
  ::fivetran_sdk::DropdownField* mutable_dropdown_field();
  void set_allocated_dropdown_field(::fivetran_sdk::DropdownField* dropdown_field);
  private:
  const ::fivetran_sdk::DropdownField& _internal_dropdown_field() const;
  ::fivetran_sdk::DropdownField* _internal_mutable_dropdown_field();
  public:
  void unsafe_arena_set_allocated_dropdown_field(
      ::fivetran_sdk::DropdownField* dropdown_field);
  ::fivetran_sdk::DropdownField* unsafe_arena_release_dropdown_field();
  // .fivetran_sdk.ToggleField toggle_field = 7;
  bool has_toggle_field() const;
  private:
  bool _internal_has_toggle_field() const;

  public:
  void clear_toggle_field() ;
  const ::fivetran_sdk::ToggleField& toggle_field() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::ToggleField* release_toggle_field();
  ::fivetran_sdk::ToggleField* mutable_toggle_field();
  void set_allocated_toggle_field(::fivetran_sdk::ToggleField* toggle_field);
  private:
  const ::fivetran_sdk::ToggleField& _internal_toggle_field() const;
  ::fivetran_sdk::ToggleField* _internal_mutable_toggle_field();
  public:
  void unsafe_arena_set_allocated_toggle_field(
      ::fivetran_sdk::ToggleField* toggle_field);
  ::fivetran_sdk::ToggleField* unsafe_arena_release_toggle_field();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.FormField)
 private:
  class _Internal;
  void set_has_text_field();
  void set_has_dropdown_field();
  void set_has_toggle_field();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool required_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int text_field_;
      ::fivetran_sdk::DropdownField* dropdown_field_;
      ::fivetran_sdk::ToggleField* toggle_field_;
    } type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class DropdownField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.DropdownField) */ {
 public:
  inline DropdownField() : DropdownField(nullptr) {}
  ~DropdownField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DropdownField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropdownField(const DropdownField& from);
  DropdownField(DropdownField&& from) noexcept
    : DropdownField() {
    *this = ::std::move(from);
  }

  inline DropdownField& operator=(const DropdownField& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropdownField& operator=(DropdownField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropdownField& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropdownField* internal_default_instance() {
    return reinterpret_cast<const DropdownField*>(
               &_DropdownField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DropdownField& a, DropdownField& b) {
    a.Swap(&b);
  }
  inline void Swap(DropdownField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropdownField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropdownField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropdownField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropdownField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropdownField& from) {
    DropdownField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropdownField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.DropdownField";
  }
  protected:
  explicit DropdownField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropdownFieldFieldNumber = 1,
  };
  // repeated string dropdown_field = 1;
  int dropdown_field_size() const;
  private:
  int _internal_dropdown_field_size() const;

  public:
  void clear_dropdown_field() ;
  const std::string& dropdown_field(int index) const;
  std::string* mutable_dropdown_field(int index);
  void set_dropdown_field(int index, const std::string& value);
  void set_dropdown_field(int index, std::string&& value);
  void set_dropdown_field(int index, const char* value);
  void set_dropdown_field(int index, const char* value, std::size_t size);
  void set_dropdown_field(int index, absl::string_view value);
  std::string* add_dropdown_field();
  void add_dropdown_field(const std::string& value);
  void add_dropdown_field(std::string&& value);
  void add_dropdown_field(const char* value);
  void add_dropdown_field(const char* value, std::size_t size);
  void add_dropdown_field(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dropdown_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dropdown_field();

  private:
  const std::string& _internal_dropdown_field(int index) const;
  std::string* _internal_add_dropdown_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_dropdown_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_dropdown_field();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.DropdownField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dropdown_field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class ToggleField final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:fivetran_sdk.ToggleField) */ {
 public:
  inline ToggleField() : ToggleField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ToggleField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleField(const ToggleField& from);
  ToggleField(ToggleField&& from) noexcept
    : ToggleField() {
    *this = ::std::move(from);
  }

  inline ToggleField& operator=(const ToggleField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleField& operator=(ToggleField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleField* internal_default_instance() {
    return reinterpret_cast<const ToggleField*>(
               &_ToggleField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ToggleField& a, ToggleField& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ToggleField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ToggleField& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.ToggleField";
  }
  protected:
  explicit ToggleField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fivetran_sdk.ToggleField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class ConfigurationTest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.ConfigurationTest) */ {
 public:
  inline ConfigurationTest() : ConfigurationTest(nullptr) {}
  ~ConfigurationTest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigurationTest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationTest(const ConfigurationTest& from);
  ConfigurationTest(ConfigurationTest&& from) noexcept
    : ConfigurationTest() {
    *this = ::std::move(from);
  }

  inline ConfigurationTest& operator=(const ConfigurationTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationTest& operator=(ConfigurationTest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigurationTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationTest* internal_default_instance() {
    return reinterpret_cast<const ConfigurationTest*>(
               &_ConfigurationTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConfigurationTest& a, ConfigurationTest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationTest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationTest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigurationTest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigurationTest& from) {
    ConfigurationTest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigurationTest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.ConfigurationTest";
  }
  protected:
  explicit ConfigurationTest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLabelFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string label = 2;
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.ConfigurationTest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TestRequest_ConfigurationEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestRequest_ConfigurationEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TestRequest_ConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestRequest_ConfigurationEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TestRequest_ConfigurationEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestRequest_ConfigurationEntry_DoNotUse& other);
  static const TestRequest_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestRequest_ConfigurationEntry_DoNotUse*>(&_TestRequest_ConfigurationEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.TestRequest.ConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fivetran_sdk.TestRequest.ConfigurationEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.TestRequest) */ {
 public:
  inline TestRequest() : TestRequest(nullptr) {}
  ~TestRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRequest(const TestRequest& from);
  TestRequest(TestRequest&& from) noexcept
    : TestRequest() {
    *this = ::std::move(from);
  }

  inline TestRequest& operator=(const TestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRequest& operator=(TestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRequest* internal_default_instance() {
    return reinterpret_cast<const TestRequest*>(
               &_TestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TestRequest& a, TestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRequest& from) {
    TestRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.TestRequest";
  }
  protected:
  explicit TestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, string> configuration = 2;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration();
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.TestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TestRequest_ConfigurationEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.TestResponse) */ {
 public:
  inline TestResponse() : TestResponse(nullptr) {}
  ~TestResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestResponse(const TestResponse& from);
  TestResponse(TestResponse&& from) noexcept
    : TestResponse() {
    *this = ::std::move(from);
  }

  inline TestResponse& operator=(const TestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestResponse& operator=(TestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSuccess = 1,
    kFailure = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const TestResponse* internal_default_instance() {
    return reinterpret_cast<const TestResponse*>(
               &_TestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TestResponse& a, TestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestResponse& from) {
    TestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.TestResponse";
  }
  protected:
  explicit TestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kFailureFieldNumber = 2,
  };
  // bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // string failure = 2;
  bool has_failure() const;
  void clear_failure() ;
  const std::string& failure() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure(Arg_&& arg, Args_... args);
  std::string* mutable_failure();
  PROTOBUF_NODISCARD std::string* release_failure();
  void set_allocated_failure(std::string* ptr);

  private:
  const std::string& _internal_failure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure(
      const std::string& value);
  std::string* _internal_mutable_failure();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.TestResponse)
 private:
  class _Internal;
  void set_has_success();
  void set_has_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool success_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class SchemaList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.SchemaList) */ {
 public:
  inline SchemaList() : SchemaList(nullptr) {}
  ~SchemaList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaList(const SchemaList& from);
  SchemaList(SchemaList&& from) noexcept
    : SchemaList() {
    *this = ::std::move(from);
  }

  inline SchemaList& operator=(const SchemaList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaList& operator=(SchemaList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaList* internal_default_instance() {
    return reinterpret_cast<const SchemaList*>(
               &_SchemaList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SchemaList& a, SchemaList& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaList& from) {
    SchemaList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.SchemaList";
  }
  protected:
  explicit SchemaList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemasFieldNumber = 1,
  };
  // repeated .fivetran_sdk.Schema schemas = 1;
  int schemas_size() const;
  private:
  int _internal_schemas_size() const;

  public:
  void clear_schemas() ;
  ::fivetran_sdk::Schema* mutable_schemas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Schema >*
      mutable_schemas();
  private:
  const ::fivetran_sdk::Schema& _internal_schemas(int index) const;
  ::fivetran_sdk::Schema* _internal_add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Schema>& _internal_schemas() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Schema>* _internal_mutable_schemas();
  public:
  const ::fivetran_sdk::Schema& schemas(int index) const;
  ::fivetran_sdk::Schema* add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Schema >&
      schemas() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.SchemaList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Schema > schemas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TableList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.TableList) */ {
 public:
  inline TableList() : TableList(nullptr) {}
  ~TableList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TableList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableList(const TableList& from);
  TableList(TableList&& from) noexcept
    : TableList() {
    *this = ::std::move(from);
  }

  inline TableList& operator=(const TableList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableList& operator=(TableList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableList* internal_default_instance() {
    return reinterpret_cast<const TableList*>(
               &_TableList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TableList& a, TableList& b) {
    a.Swap(&b);
  }
  inline void Swap(TableList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableList& from) {
    TableList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.TableList";
  }
  protected:
  explicit TableList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
  };
  // repeated .fivetran_sdk.Table tables = 1;
  int tables_size() const;
  private:
  int _internal_tables_size() const;

  public:
  void clear_tables() ;
  ::fivetran_sdk::Table* mutable_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >*
      mutable_tables();
  private:
  const ::fivetran_sdk::Table& _internal_tables(int index) const;
  ::fivetran_sdk::Table* _internal_add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>& _internal_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>* _internal_mutable_tables();
  public:
  const ::fivetran_sdk::Table& tables(int index) const;
  ::fivetran_sdk::Table* add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >&
      tables() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.TableList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table > tables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .fivetran_sdk.Table tables = 2;
  int tables_size() const;
  private:
  int _internal_tables_size() const;

  public:
  void clear_tables() ;
  ::fivetran_sdk::Table* mutable_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >*
      mutable_tables();
  private:
  const ::fivetran_sdk::Table& _internal_tables(int index) const;
  ::fivetran_sdk::Table* _internal_add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>& _internal_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>* _internal_mutable_tables();
  public:
  const ::fivetran_sdk::Table& tables(int index) const;
  ::fivetran_sdk::Table* add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >&
      tables() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table > tables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class DecimalParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.DecimalParams) */ {
 public:
  inline DecimalParams() : DecimalParams(nullptr) {}
  ~DecimalParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DecimalParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecimalParams(const DecimalParams& from);
  DecimalParams(DecimalParams&& from) noexcept
    : DecimalParams() {
    *this = ::std::move(from);
  }

  inline DecimalParams& operator=(const DecimalParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecimalParams& operator=(DecimalParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecimalParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecimalParams* internal_default_instance() {
    return reinterpret_cast<const DecimalParams*>(
               &_DecimalParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DecimalParams& a, DecimalParams& b) {
    a.Swap(&b);
  }
  inline void Swap(DecimalParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecimalParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecimalParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecimalParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecimalParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DecimalParams& from) {
    DecimalParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecimalParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.DecimalParams";
  }
  protected:
  explicit DecimalParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrecisionFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // uint32 precision = 1;
  void clear_precision() ;
  ::uint32_t precision() const;
  void set_precision(::uint32_t value);

  private:
  ::uint32_t _internal_precision() const;
  void _internal_set_precision(::uint32_t value);

  public:
  // uint32 scale = 2;
  void clear_scale() ;
  ::uint32_t scale() const;
  void set_scale(::uint32_t value);

  private:
  ::uint32_t _internal_scale() const;
  void _internal_set_scale(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.DecimalParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t precision_;
    ::uint32_t scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class ValueType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.ValueType) */ {
 public:
  inline ValueType() : ValueType(nullptr) {}
  ~ValueType() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValueType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueType(const ValueType& from);
  ValueType(ValueType&& from) noexcept
    : ValueType() {
    *this = ::std::move(from);
  }

  inline ValueType& operator=(const ValueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueType& operator=(ValueType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueType& default_instance() {
    return *internal_default_instance();
  }
  enum InnerCase {
    kNull = 1,
    kBool = 2,
    kShort = 3,
    kInt = 4,
    kLong = 5,
    kFloat = 6,
    kDouble = 7,
    kNaiveDate = 8,
    kNaiveDatetime = 9,
    kUtcDatetime = 10,
    kDecimal = 11,
    kBinary = 12,
    kString = 13,
    kJson = 14,
    kXml = 15,
    INNER_NOT_SET = 0,
  };

  static inline const ValueType* internal_default_instance() {
    return reinterpret_cast<const ValueType*>(
               &_ValueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ValueType& a, ValueType& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValueType& from) {
    ValueType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.ValueType";
  }
  protected:
  explicit ValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullFieldNumber = 1,
    kBoolFieldNumber = 2,
    kShortFieldNumber = 3,
    kIntFieldNumber = 4,
    kLongFieldNumber = 5,
    kFloatFieldNumber = 6,
    kDoubleFieldNumber = 7,
    kNaiveDateFieldNumber = 8,
    kNaiveDatetimeFieldNumber = 9,
    kUtcDatetimeFieldNumber = 10,
    kDecimalFieldNumber = 11,
    kBinaryFieldNumber = 12,
    kStringFieldNumber = 13,
    kJsonFieldNumber = 14,
    kXmlFieldNumber = 15,
  };
  // bool null = 1;
  bool has_null() const;
  void clear_null() ;
  bool null() const;
  void set_null(bool value);

  private:
  bool _internal_null() const;
  void _internal_set_null(bool value);

  public:
  // bool bool = 2;
  bool has_bool_() const;
  void clear_bool_() ;
  bool bool_() const;
  void set_bool_(bool value);

  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);

  public:
  // int32 short = 3;
  bool has_short_() const;
  void clear_short_() ;
  ::int32_t short_() const;
  void set_short_(::int32_t value);

  private:
  ::int32_t _internal_short_() const;
  void _internal_set_short_(::int32_t value);

  public:
  // int32 int = 4;
  bool has_int_() const;
  void clear_int_() ;
  ::int32_t int_() const;
  void set_int_(::int32_t value);

  private:
  ::int32_t _internal_int_() const;
  void _internal_set_int_(::int32_t value);

  public:
  // int64 long = 5;
  bool has_long_() const;
  void clear_long_() ;
  ::int64_t long_() const;
  void set_long_(::int64_t value);

  private:
  ::int64_t _internal_long_() const;
  void _internal_set_long_(::int64_t value);

  public:
  // float float = 6;
  bool has_float_() const;
  void clear_float_() ;
  float float_() const;
  void set_float_(float value);

  private:
  float _internal_float_() const;
  void _internal_set_float_(float value);

  public:
  // double double = 7;
  bool has_double_() const;
  void clear_double_() ;
  double double_() const;
  void set_double_(double value);

  private:
  double _internal_double_() const;
  void _internal_set_double_(double value);

  public:
  // .google.protobuf.Timestamp naive_date = 8;
  bool has_naive_date() const;
  private:
  bool _internal_has_naive_date() const;

  public:
  void clear_naive_date() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& naive_date() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_naive_date();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_naive_date();
  void set_allocated_naive_date(::PROTOBUF_NAMESPACE_ID::Timestamp* naive_date);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_naive_date() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_naive_date();
  public:
  void unsafe_arena_set_allocated_naive_date(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* naive_date);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_naive_date();
  // .google.protobuf.Timestamp naive_datetime = 9;
  bool has_naive_datetime() const;
  private:
  bool _internal_has_naive_datetime() const;

  public:
  void clear_naive_datetime() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& naive_datetime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_naive_datetime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_naive_datetime();
  void set_allocated_naive_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* naive_datetime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_naive_datetime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_naive_datetime();
  public:
  void unsafe_arena_set_allocated_naive_datetime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* naive_datetime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_naive_datetime();
  // .google.protobuf.Timestamp utc_datetime = 10;
  bool has_utc_datetime() const;
  private:
  bool _internal_has_utc_datetime() const;

  public:
  void clear_utc_datetime() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& utc_datetime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_utc_datetime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_utc_datetime();
  void set_allocated_utc_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* utc_datetime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_utc_datetime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_utc_datetime();
  public:
  void unsafe_arena_set_allocated_utc_datetime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* utc_datetime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_utc_datetime();
  // string decimal = 11;
  bool has_decimal() const;
  void clear_decimal() ;
  const std::string& decimal() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_decimal(Arg_&& arg, Args_... args);
  std::string* mutable_decimal();
  PROTOBUF_NODISCARD std::string* release_decimal();
  void set_allocated_decimal(std::string* ptr);

  private:
  const std::string& _internal_decimal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decimal(
      const std::string& value);
  std::string* _internal_mutable_decimal();

  public:
  // bytes binary = 12;
  bool has_binary() const;
  void clear_binary() ;
  const std::string& binary() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary(Arg_&& arg, Args_... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* ptr);

  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(
      const std::string& value);
  std::string* _internal_mutable_binary();

  public:
  // string string = 13;
  bool has_string() const;
  void clear_string() ;
  const std::string& string() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string(Arg_&& arg, Args_... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* ptr);

  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(
      const std::string& value);
  std::string* _internal_mutable_string();

  public:
  // string json = 14;
  bool has_json() const;
  void clear_json() ;
  const std::string& json() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_json(Arg_&& arg, Args_... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* ptr);

  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(
      const std::string& value);
  std::string* _internal_mutable_json();

  public:
  // string xml = 15;
  bool has_xml() const;
  void clear_xml() ;
  const std::string& xml() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_xml(Arg_&& arg, Args_... args);
  std::string* mutable_xml();
  PROTOBUF_NODISCARD std::string* release_xml();
  void set_allocated_xml(std::string* ptr);

  private:
  const std::string& _internal_xml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xml(
      const std::string& value);
  std::string* _internal_mutable_xml();

  public:
  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:fivetran_sdk.ValueType)
 private:
  class _Internal;
  void set_has_null();
  void set_has_bool_();
  void set_has_short_();
  void set_has_int_();
  void set_has_long_();
  void set_has_float_();
  void set_has_double_();
  void set_has_naive_date();
  void set_has_naive_datetime();
  void set_has_utc_datetime();
  void set_has_decimal();
  void set_has_binary();
  void set_has_string();
  void set_has_json();
  void set_has_xml();

  inline bool has_inner() const;
  inline void clear_has_inner();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union InnerUnion {
      constexpr InnerUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool null_;
      bool bool__;
      ::int32_t short__;
      ::int32_t int__;
      ::int64_t long__;
      float float__;
      double double__;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* naive_date_;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* naive_datetime_;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* utc_datetime_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decimal_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xml_;
    } inner_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Table final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .fivetran_sdk.Column columns = 2;
  int columns_size() const;
  private:
  int _internal_columns_size() const;

  public:
  void clear_columns() ;
  ::fivetran_sdk::Column* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Column >*
      mutable_columns();
  private:
  const ::fivetran_sdk::Column& _internal_columns(int index) const;
  ::fivetran_sdk::Column* _internal_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Column>& _internal_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Column>* _internal_mutable_columns();
  public:
  const ::fivetran_sdk::Column& columns(int index) const;
  ::fivetran_sdk::Column* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Column >&
      columns() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Column > columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Column final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fivetran_sdk.Column) */ {
 public:
  inline Column() : Column(nullptr) {}
  ~Column() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Column(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Column(const Column& from);
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline Column& operator=(Column&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Column& default_instance() {
    return *internal_default_instance();
  }
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }
  inline void Swap(Column* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Column* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Column& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Column& from) {
    Column::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "fivetran_sdk.Column";
  }
  protected:
  explicit Column(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDecimalFieldNumber = 4,
    kTypeFieldNumber = 2,
    kPrimaryKeyFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .fivetran_sdk.DecimalParams decimal = 4;
  bool has_decimal() const;
  void clear_decimal() ;
  const ::fivetran_sdk::DecimalParams& decimal() const;
  PROTOBUF_NODISCARD ::fivetran_sdk::DecimalParams* release_decimal();
  ::fivetran_sdk::DecimalParams* mutable_decimal();
  void set_allocated_decimal(::fivetran_sdk::DecimalParams* decimal);
  private:
  const ::fivetran_sdk::DecimalParams& _internal_decimal() const;
  ::fivetran_sdk::DecimalParams* _internal_mutable_decimal();
  public:
  void unsafe_arena_set_allocated_decimal(
      ::fivetran_sdk::DecimalParams* decimal);
  ::fivetran_sdk::DecimalParams* unsafe_arena_release_decimal();
  // .fivetran_sdk.DataType type = 2;
  void clear_type() ;
  ::fivetran_sdk::DataType type() const;
  void set_type(::fivetran_sdk::DataType value);

  private:
  ::fivetran_sdk::DataType _internal_type() const;
  void _internal_set_type(::fivetran_sdk::DataType value);

  public:
  // bool primary_key = 3;
  void clear_primary_key() ;
  bool primary_key() const;
  void set_primary_key(bool value);

  private:
  bool _internal_primary_key() const;
  void _internal_set_primary_key(bool value);

  public:
  // @@protoc_insertion_point(class_scope:fivetran_sdk.Column)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::fivetran_sdk::DecimalParams* decimal_;
    int type_;
    bool primary_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConfigurationFormRequest

// -------------------------------------------------------------------

// ConfigurationFormResponse

// bool schema_selection_supported = 1;
inline void ConfigurationFormResponse::clear_schema_selection_supported() {
  _impl_.schema_selection_supported_ = false;
}
inline bool ConfigurationFormResponse::schema_selection_supported() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationFormResponse.schema_selection_supported)
  return _internal_schema_selection_supported();
}
inline void ConfigurationFormResponse::set_schema_selection_supported(bool value) {
  _internal_set_schema_selection_supported(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ConfigurationFormResponse.schema_selection_supported)
}
inline bool ConfigurationFormResponse::_internal_schema_selection_supported() const {
  return _impl_.schema_selection_supported_;
}
inline void ConfigurationFormResponse::_internal_set_schema_selection_supported(bool value) {
  ;
  _impl_.schema_selection_supported_ = value;
}

// bool table_selection_supported = 2;
inline void ConfigurationFormResponse::clear_table_selection_supported() {
  _impl_.table_selection_supported_ = false;
}
inline bool ConfigurationFormResponse::table_selection_supported() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationFormResponse.table_selection_supported)
  return _internal_table_selection_supported();
}
inline void ConfigurationFormResponse::set_table_selection_supported(bool value) {
  _internal_set_table_selection_supported(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ConfigurationFormResponse.table_selection_supported)
}
inline bool ConfigurationFormResponse::_internal_table_selection_supported() const {
  return _impl_.table_selection_supported_;
}
inline void ConfigurationFormResponse::_internal_set_table_selection_supported(bool value) {
  ;
  _impl_.table_selection_supported_ = value;
}

// repeated .fivetran_sdk.FormField fields = 3;
inline int ConfigurationFormResponse::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int ConfigurationFormResponse::fields_size() const {
  return _internal_fields_size();
}
inline void ConfigurationFormResponse::clear_fields() {
  _internal_mutable_fields()->Clear();
}
inline ::fivetran_sdk::FormField* ConfigurationFormResponse::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ConfigurationFormResponse.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::FormField >*
ConfigurationFormResponse::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.ConfigurationFormResponse.fields)
  return _internal_mutable_fields();
}
inline const ::fivetran_sdk::FormField& ConfigurationFormResponse::_internal_fields(int index) const {
  return _internal_fields().Get(index);
}
inline const ::fivetran_sdk::FormField& ConfigurationFormResponse::fields(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationFormResponse.fields)
  return _internal_fields(index);
}
inline ::fivetran_sdk::FormField* ConfigurationFormResponse::_internal_add_fields() {
  return _internal_mutable_fields()->Add();
}
inline ::fivetran_sdk::FormField* ConfigurationFormResponse::add_fields() {
  ::fivetran_sdk::FormField* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:fivetran_sdk.ConfigurationFormResponse.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::FormField >&
ConfigurationFormResponse::fields() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.ConfigurationFormResponse.fields)
  return _internal_fields();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::FormField>&
ConfigurationFormResponse::_internal_fields() const {
  return _impl_.fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::FormField>*
ConfigurationFormResponse::_internal_mutable_fields() {
  return &_impl_.fields_;
}

// repeated .fivetran_sdk.ConfigurationTest tests = 4;
inline int ConfigurationFormResponse::_internal_tests_size() const {
  return _impl_.tests_.size();
}
inline int ConfigurationFormResponse::tests_size() const {
  return _internal_tests_size();
}
inline void ConfigurationFormResponse::clear_tests() {
  _internal_mutable_tests()->Clear();
}
inline ::fivetran_sdk::ConfigurationTest* ConfigurationFormResponse::mutable_tests(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ConfigurationFormResponse.tests)
  return _internal_mutable_tests()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::ConfigurationTest >*
ConfigurationFormResponse::mutable_tests() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.ConfigurationFormResponse.tests)
  return _internal_mutable_tests();
}
inline const ::fivetran_sdk::ConfigurationTest& ConfigurationFormResponse::_internal_tests(int index) const {
  return _internal_tests().Get(index);
}
inline const ::fivetran_sdk::ConfigurationTest& ConfigurationFormResponse::tests(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationFormResponse.tests)
  return _internal_tests(index);
}
inline ::fivetran_sdk::ConfigurationTest* ConfigurationFormResponse::_internal_add_tests() {
  return _internal_mutable_tests()->Add();
}
inline ::fivetran_sdk::ConfigurationTest* ConfigurationFormResponse::add_tests() {
  ::fivetran_sdk::ConfigurationTest* _add = _internal_add_tests();
  // @@protoc_insertion_point(field_add:fivetran_sdk.ConfigurationFormResponse.tests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::ConfigurationTest >&
ConfigurationFormResponse::tests() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.ConfigurationFormResponse.tests)
  return _internal_tests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::ConfigurationTest>&
ConfigurationFormResponse::_internal_tests() const {
  return _impl_.tests_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::ConfigurationTest>*
ConfigurationFormResponse::_internal_mutable_tests() {
  return &_impl_.tests_;
}

// -------------------------------------------------------------------

// FormField

// string name = 1;
inline void FormField::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FormField::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FormField::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.FormField.name)
}
inline std::string* FormField::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.FormField.name)
  return _s;
}
inline const std::string& FormField::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FormField::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FormField::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* FormField::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.FormField.name)
  return _impl_.name_.Release();
}
inline void FormField::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.FormField.name)
}

// string label = 2;
inline void FormField::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& FormField::label() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FormField::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.FormField.label)
}
inline std::string* FormField::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.FormField.label)
  return _s;
}
inline const std::string& FormField::_internal_label() const {
  return _impl_.label_.Get();
}
inline void FormField::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* FormField::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* FormField::release_label() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.FormField.label)
  return _impl_.label_.Release();
}
inline void FormField::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.FormField.label)
}

// bool required = 3;
inline void FormField::clear_required() {
  _impl_.required_ = false;
}
inline bool FormField::required() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.required)
  return _internal_required();
}
inline void FormField::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.FormField.required)
}
inline bool FormField::_internal_required() const {
  return _impl_.required_;
}
inline void FormField::_internal_set_required(bool value) {
  ;
  _impl_.required_ = value;
}

// optional string description = 4;
inline bool FormField::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FormField::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FormField::description() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FormField::set_description(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.FormField.description)
}
inline std::string* FormField::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.FormField.description)
  return _s;
}
inline const std::string& FormField::_internal_description() const {
  return _impl_.description_.Get();
}
inline void FormField::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* FormField::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* FormField::release_description() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.FormField.description)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FormField::set_allocated_description(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.FormField.description)
}

// .fivetran_sdk.TextField text_field = 5;
inline bool FormField::has_text_field() const {
  return type_case() == kTextField;
}
inline void FormField::set_has_text_field() {
  _impl_._oneof_case_[0] = kTextField;
}
inline void FormField::clear_text_field() {
  if (type_case() == kTextField) {
    _impl_.type_.text_field_ = 0;
    clear_has_type();
  }
}
inline ::fivetran_sdk::TextField FormField::text_field() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.text_field)
  return _internal_text_field();
}
inline void FormField::set_text_field(::fivetran_sdk::TextField value) {
   _internal_set_text_field(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.FormField.text_field)
}
inline ::fivetran_sdk::TextField FormField::_internal_text_field() const {
  if (type_case() == kTextField) {
    return static_cast<::fivetran_sdk::TextField>(_impl_.type_.text_field_);
  }
  return static_cast<::fivetran_sdk::TextField>(0);
}
inline void FormField::_internal_set_text_field(::fivetran_sdk::TextField value) {
  if (type_case() != kTextField) {
    clear_type();
    set_has_text_field();
  }
  _impl_.type_.text_field_ = value;
}

// .fivetran_sdk.DropdownField dropdown_field = 6;
inline bool FormField::has_dropdown_field() const {
  return type_case() == kDropdownField;
}
inline bool FormField::_internal_has_dropdown_field() const {
  return type_case() == kDropdownField;
}
inline void FormField::set_has_dropdown_field() {
  _impl_._oneof_case_[0] = kDropdownField;
}
inline void FormField::clear_dropdown_field() {
  if (type_case() == kDropdownField) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.dropdown_field_;
    }
    clear_has_type();
  }
}
inline ::fivetran_sdk::DropdownField* FormField::release_dropdown_field() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.FormField.dropdown_field)
  if (type_case() == kDropdownField) {
    clear_has_type();
    ::fivetran_sdk::DropdownField* temp = _impl_.type_.dropdown_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.dropdown_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fivetran_sdk::DropdownField& FormField::_internal_dropdown_field() const {
  return type_case() == kDropdownField
      ? *_impl_.type_.dropdown_field_
      : reinterpret_cast<::fivetran_sdk::DropdownField&>(::fivetran_sdk::_DropdownField_default_instance_);
}
inline const ::fivetran_sdk::DropdownField& FormField::dropdown_field() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.dropdown_field)
  return _internal_dropdown_field();
}
inline ::fivetran_sdk::DropdownField* FormField::unsafe_arena_release_dropdown_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.FormField.dropdown_field)
  if (type_case() == kDropdownField) {
    clear_has_type();
    ::fivetran_sdk::DropdownField* temp = _impl_.type_.dropdown_field_;
    _impl_.type_.dropdown_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormField::unsafe_arena_set_allocated_dropdown_field(::fivetran_sdk::DropdownField* dropdown_field) {
  clear_type();
  if (dropdown_field) {
    set_has_dropdown_field();
    _impl_.type_.dropdown_field_ = dropdown_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.FormField.dropdown_field)
}
inline ::fivetran_sdk::DropdownField* FormField::_internal_mutable_dropdown_field() {
  if (type_case() != kDropdownField) {
    clear_type();
    set_has_dropdown_field();
    _impl_.type_.dropdown_field_ = CreateMaybeMessage< ::fivetran_sdk::DropdownField >(GetArenaForAllocation());
  }
  return _impl_.type_.dropdown_field_;
}
inline ::fivetran_sdk::DropdownField* FormField::mutable_dropdown_field() {
  ::fivetran_sdk::DropdownField* _msg = _internal_mutable_dropdown_field();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.FormField.dropdown_field)
  return _msg;
}

// .fivetran_sdk.ToggleField toggle_field = 7;
inline bool FormField::has_toggle_field() const {
  return type_case() == kToggleField;
}
inline bool FormField::_internal_has_toggle_field() const {
  return type_case() == kToggleField;
}
inline void FormField::set_has_toggle_field() {
  _impl_._oneof_case_[0] = kToggleField;
}
inline void FormField::clear_toggle_field() {
  if (type_case() == kToggleField) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.toggle_field_;
    }
    clear_has_type();
  }
}
inline ::fivetran_sdk::ToggleField* FormField::release_toggle_field() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.FormField.toggle_field)
  if (type_case() == kToggleField) {
    clear_has_type();
    ::fivetran_sdk::ToggleField* temp = _impl_.type_.toggle_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.toggle_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fivetran_sdk::ToggleField& FormField::_internal_toggle_field() const {
  return type_case() == kToggleField
      ? *_impl_.type_.toggle_field_
      : reinterpret_cast<::fivetran_sdk::ToggleField&>(::fivetran_sdk::_ToggleField_default_instance_);
}
inline const ::fivetran_sdk::ToggleField& FormField::toggle_field() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.FormField.toggle_field)
  return _internal_toggle_field();
}
inline ::fivetran_sdk::ToggleField* FormField::unsafe_arena_release_toggle_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.FormField.toggle_field)
  if (type_case() == kToggleField) {
    clear_has_type();
    ::fivetran_sdk::ToggleField* temp = _impl_.type_.toggle_field_;
    _impl_.type_.toggle_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormField::unsafe_arena_set_allocated_toggle_field(::fivetran_sdk::ToggleField* toggle_field) {
  clear_type();
  if (toggle_field) {
    set_has_toggle_field();
    _impl_.type_.toggle_field_ = toggle_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.FormField.toggle_field)
}
inline ::fivetran_sdk::ToggleField* FormField::_internal_mutable_toggle_field() {
  if (type_case() != kToggleField) {
    clear_type();
    set_has_toggle_field();
    _impl_.type_.toggle_field_ = CreateMaybeMessage< ::fivetran_sdk::ToggleField >(GetArenaForAllocation());
  }
  return _impl_.type_.toggle_field_;
}
inline ::fivetran_sdk::ToggleField* FormField::mutable_toggle_field() {
  ::fivetran_sdk::ToggleField* _msg = _internal_mutable_toggle_field();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.FormField.toggle_field)
  return _msg;
}

inline bool FormField::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FormField::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline FormField::TypeCase FormField::type_case() const {
  return FormField::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DropdownField

// repeated string dropdown_field = 1;
inline int DropdownField::_internal_dropdown_field_size() const {
  return _impl_.dropdown_field_.size();
}
inline int DropdownField::dropdown_field_size() const {
  return _internal_dropdown_field_size();
}
inline void DropdownField::clear_dropdown_field() {
  _internal_mutable_dropdown_field()->Clear();
}
inline std::string* DropdownField::add_dropdown_field() {
  std::string* _s = _internal_add_dropdown_field();
  // @@protoc_insertion_point(field_add_mutable:fivetran_sdk.DropdownField.dropdown_field)
  return _s;
}
inline const std::string& DropdownField::dropdown_field(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DropdownField.dropdown_field)
  return _internal_dropdown_field(index);
}
inline std::string* DropdownField::mutable_dropdown_field(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.DropdownField.dropdown_field)
  return _internal_mutable_dropdown_field()->Mutable(index);
}
inline void DropdownField::set_dropdown_field(int index, const std::string& value) {
  _internal_mutable_dropdown_field()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::set_dropdown_field(int index, std::string&& value) {
  _internal_mutable_dropdown_field()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::set_dropdown_field(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dropdown_field()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::set_dropdown_field(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dropdown_field()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::set_dropdown_field(int index, absl::string_view value) {
  _internal_mutable_dropdown_field()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::add_dropdown_field(const std::string& value) {
  _internal_mutable_dropdown_field()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::add_dropdown_field(std::string&& value) {
  _internal_mutable_dropdown_field()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::add_dropdown_field(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dropdown_field()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::add_dropdown_field(const char* value, std::size_t size) {
  _internal_mutable_dropdown_field()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fivetran_sdk.DropdownField.dropdown_field)
}
inline void DropdownField::add_dropdown_field(absl::string_view value) {
  _internal_mutable_dropdown_field()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:fivetran_sdk.DropdownField.dropdown_field)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DropdownField::dropdown_field() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.DropdownField.dropdown_field)
  return _internal_dropdown_field();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* DropdownField::mutable_dropdown_field() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.DropdownField.dropdown_field)
  return _internal_mutable_dropdown_field();
}
inline const std::string& DropdownField::_internal_dropdown_field(int index) const {
  return _internal_dropdown_field().Get(index);
}
inline std::string* DropdownField::_internal_add_dropdown_field() {
  return _internal_mutable_dropdown_field()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DropdownField::_internal_dropdown_field() const {
  return _impl_.dropdown_field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DropdownField::_internal_mutable_dropdown_field() {
  return &_impl_.dropdown_field_;
}

// -------------------------------------------------------------------

// ToggleField

// -------------------------------------------------------------------

// ConfigurationTest

// string name = 1;
inline void ConfigurationTest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConfigurationTest::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationTest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfigurationTest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ConfigurationTest.name)
}
inline std::string* ConfigurationTest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ConfigurationTest.name)
  return _s;
}
inline const std::string& ConfigurationTest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConfigurationTest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationTest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ConfigurationTest::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ConfigurationTest.name)
  return _impl_.name_.Release();
}
inline void ConfigurationTest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ConfigurationTest.name)
}

// string label = 2;
inline void ConfigurationTest::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& ConfigurationTest::label() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ConfigurationTest.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfigurationTest::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ConfigurationTest.label)
}
inline std::string* ConfigurationTest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ConfigurationTest.label)
  return _s;
}
inline const std::string& ConfigurationTest::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ConfigurationTest::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigurationTest::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* ConfigurationTest::release_label() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ConfigurationTest.label)
  return _impl_.label_.Release();
}
inline void ConfigurationTest::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ConfigurationTest.label)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestRequest

// string name = 1;
inline void TestRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestRequest::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TestRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TestRequest.name)
}
inline std::string* TestRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TestRequest.name)
  return _s;
}
inline const std::string& TestRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TestRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestRequest::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TestRequest.name)
  return _impl_.name_.Release();
}
inline void TestRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TestRequest.name)
}

// map<string, string> configuration = 2;
inline int TestRequest::_internal_configuration_size() const {
  return _impl_.configuration_.size();
}
inline int TestRequest::configuration_size() const {
  return _internal_configuration_size();
}
inline void TestRequest::clear_configuration() {
  _impl_.configuration_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TestRequest::_internal_configuration() const {
  return _impl_.configuration_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TestRequest::configuration() const {
  // @@protoc_insertion_point(field_map:fivetran_sdk.TestRequest.configuration)
  return _internal_configuration();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TestRequest::_internal_mutable_configuration() {
  return _impl_.configuration_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TestRequest::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:fivetran_sdk.TestRequest.configuration)
  return _internal_mutable_configuration();
}

// -------------------------------------------------------------------

// TestResponse

// bool success = 1;
inline bool TestResponse::has_success() const {
  return response_case() == kSuccess;
}
inline void TestResponse::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void TestResponse::clear_success() {
  if (response_case() == kSuccess) {
    _impl_.response_.success_ = false;
    clear_has_response();
  }
}
inline bool TestResponse::success() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TestResponse.success)
  return _internal_success();
}
inline void TestResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.TestResponse.success)
}
inline bool TestResponse::_internal_success() const {
  if (response_case() == kSuccess) {
    return _impl_.response_.success_;
  }
  return false;
}
inline void TestResponse::_internal_set_success(bool value) {
  if (response_case() != kSuccess) {
    clear_response();
    set_has_success();
  }
  _impl_.response_.success_ = value;
}

// string failure = 2;
inline bool TestResponse::has_failure() const {
  return response_case() == kFailure;
}
inline void TestResponse::set_has_failure() {
  _impl_._oneof_case_[0] = kFailure;
}
inline void TestResponse::clear_failure() {
  if (response_case() == kFailure) {
    _impl_.response_.failure_.Destroy();
    clear_has_response();
  }
}
inline const std::string& TestResponse::failure() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TestResponse.failure)
  return _internal_failure();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResponse::set_failure(Arg_&& arg,
                                                     Args_... args) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  _impl_.response_.failure_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.TestResponse.failure)
}
inline std::string* TestResponse::mutable_failure() {
  std::string* _s = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TestResponse.failure)
  return _s;
}
inline const std::string& TestResponse::_internal_failure() const {
  if (response_case() != kFailure) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_.failure_.Get();
}
inline void TestResponse::_internal_set_failure(const std::string& value) {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }


  _impl_.response_.failure_.Set(value, GetArenaForAllocation());
}
inline std::string* TestResponse::_internal_mutable_failure() {
  if (response_case() != kFailure) {
    clear_response();

    set_has_failure();
    _impl_.response_.failure_.InitDefault();
  }
  return _impl_.response_.failure_.Mutable( GetArenaForAllocation());
}
inline std::string* TestResponse::release_failure() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.TestResponse.failure)
  if (response_case() != kFailure) {
    return nullptr;
  }
  clear_has_response();
  return _impl_.response_.failure_.Release();
}
inline void TestResponse::set_allocated_failure(std::string* value) {
  if (has_response()) {
    clear_response();
  }
  if (value != nullptr) {
    set_has_failure();
    _impl_.response_.failure_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.TestResponse.failure)
}

inline bool TestResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void TestResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline TestResponse::ResponseCase TestResponse::response_case() const {
  return TestResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SchemaList

// repeated .fivetran_sdk.Schema schemas = 1;
inline int SchemaList::_internal_schemas_size() const {
  return _impl_.schemas_.size();
}
inline int SchemaList::schemas_size() const {
  return _internal_schemas_size();
}
inline void SchemaList::clear_schemas() {
  _internal_mutable_schemas()->Clear();
}
inline ::fivetran_sdk::Schema* SchemaList::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.SchemaList.schemas)
  return _internal_mutable_schemas()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Schema >*
SchemaList::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.SchemaList.schemas)
  return _internal_mutable_schemas();
}
inline const ::fivetran_sdk::Schema& SchemaList::_internal_schemas(int index) const {
  return _internal_schemas().Get(index);
}
inline const ::fivetran_sdk::Schema& SchemaList::schemas(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.SchemaList.schemas)
  return _internal_schemas(index);
}
inline ::fivetran_sdk::Schema* SchemaList::_internal_add_schemas() {
  return _internal_mutable_schemas()->Add();
}
inline ::fivetran_sdk::Schema* SchemaList::add_schemas() {
  ::fivetran_sdk::Schema* _add = _internal_add_schemas();
  // @@protoc_insertion_point(field_add:fivetran_sdk.SchemaList.schemas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Schema >&
SchemaList::schemas() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.SchemaList.schemas)
  return _internal_schemas();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Schema>&
SchemaList::_internal_schemas() const {
  return _impl_.schemas_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Schema>*
SchemaList::_internal_mutable_schemas() {
  return &_impl_.schemas_;
}

// -------------------------------------------------------------------

// TableList

// repeated .fivetran_sdk.Table tables = 1;
inline int TableList::_internal_tables_size() const {
  return _impl_.tables_.size();
}
inline int TableList::tables_size() const {
  return _internal_tables_size();
}
inline void TableList::clear_tables() {
  _internal_mutable_tables()->Clear();
}
inline ::fivetran_sdk::Table* TableList::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.TableList.tables)
  return _internal_mutable_tables()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >*
TableList::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.TableList.tables)
  return _internal_mutable_tables();
}
inline const ::fivetran_sdk::Table& TableList::_internal_tables(int index) const {
  return _internal_tables().Get(index);
}
inline const ::fivetran_sdk::Table& TableList::tables(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.TableList.tables)
  return _internal_tables(index);
}
inline ::fivetran_sdk::Table* TableList::_internal_add_tables() {
  return _internal_mutable_tables()->Add();
}
inline ::fivetran_sdk::Table* TableList::add_tables() {
  ::fivetran_sdk::Table* _add = _internal_add_tables();
  // @@protoc_insertion_point(field_add:fivetran_sdk.TableList.tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >&
TableList::tables() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.TableList.tables)
  return _internal_tables();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>&
TableList::_internal_tables() const {
  return _impl_.tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>*
TableList::_internal_mutable_tables() {
  return &_impl_.tables_;
}

// -------------------------------------------------------------------

// Schema

// string name = 1;
inline void Schema::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Schema.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Schema::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.Schema.name)
}
inline std::string* Schema::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Schema.name)
  return _s;
}
inline const std::string& Schema::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Schema::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.Schema.name)
  return _impl_.name_.Release();
}
inline void Schema::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.Schema.name)
}

// repeated .fivetran_sdk.Table tables = 2;
inline int Schema::_internal_tables_size() const {
  return _impl_.tables_.size();
}
inline int Schema::tables_size() const {
  return _internal_tables_size();
}
inline void Schema::clear_tables() {
  _internal_mutable_tables()->Clear();
}
inline ::fivetran_sdk::Table* Schema::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Schema.tables)
  return _internal_mutable_tables()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >*
Schema::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.Schema.tables)
  return _internal_mutable_tables();
}
inline const ::fivetran_sdk::Table& Schema::_internal_tables(int index) const {
  return _internal_tables().Get(index);
}
inline const ::fivetran_sdk::Table& Schema::tables(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Schema.tables)
  return _internal_tables(index);
}
inline ::fivetran_sdk::Table* Schema::_internal_add_tables() {
  return _internal_mutable_tables()->Add();
}
inline ::fivetran_sdk::Table* Schema::add_tables() {
  ::fivetran_sdk::Table* _add = _internal_add_tables();
  // @@protoc_insertion_point(field_add:fivetran_sdk.Schema.tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Table >&
Schema::tables() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.Schema.tables)
  return _internal_tables();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>&
Schema::_internal_tables() const {
  return _impl_.tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Table>*
Schema::_internal_mutable_tables() {
  return &_impl_.tables_;
}

// -------------------------------------------------------------------

// DecimalParams

// uint32 precision = 1;
inline void DecimalParams::clear_precision() {
  _impl_.precision_ = 0u;
}
inline ::uint32_t DecimalParams::precision() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DecimalParams.precision)
  return _internal_precision();
}
inline void DecimalParams::set_precision(::uint32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.DecimalParams.precision)
}
inline ::uint32_t DecimalParams::_internal_precision() const {
  return _impl_.precision_;
}
inline void DecimalParams::_internal_set_precision(::uint32_t value) {
  ;
  _impl_.precision_ = value;
}

// uint32 scale = 2;
inline void DecimalParams::clear_scale() {
  _impl_.scale_ = 0u;
}
inline ::uint32_t DecimalParams::scale() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.DecimalParams.scale)
  return _internal_scale();
}
inline void DecimalParams::set_scale(::uint32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.DecimalParams.scale)
}
inline ::uint32_t DecimalParams::_internal_scale() const {
  return _impl_.scale_;
}
inline void DecimalParams::_internal_set_scale(::uint32_t value) {
  ;
  _impl_.scale_ = value;
}

// -------------------------------------------------------------------

// ValueType

// bool null = 1;
inline bool ValueType::has_null() const {
  return inner_case() == kNull;
}
inline void ValueType::set_has_null() {
  _impl_._oneof_case_[0] = kNull;
}
inline void ValueType::clear_null() {
  if (inner_case() == kNull) {
    _impl_.inner_.null_ = false;
    clear_has_inner();
  }
}
inline bool ValueType::null() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.null)
  return _internal_null();
}
inline void ValueType::set_null(bool value) {
  _internal_set_null(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.null)
}
inline bool ValueType::_internal_null() const {
  if (inner_case() == kNull) {
    return _impl_.inner_.null_;
  }
  return false;
}
inline void ValueType::_internal_set_null(bool value) {
  if (inner_case() != kNull) {
    clear_inner();
    set_has_null();
  }
  _impl_.inner_.null_ = value;
}

// bool bool = 2;
inline bool ValueType::has_bool_() const {
  return inner_case() == kBool;
}
inline void ValueType::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void ValueType::clear_bool_() {
  if (inner_case() == kBool) {
    _impl_.inner_.bool__ = false;
    clear_has_inner();
  }
}
inline bool ValueType::bool_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.bool)
  return _internal_bool_();
}
inline void ValueType::set_bool_(bool value) {
  _internal_set_bool_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.bool)
}
inline bool ValueType::_internal_bool_() const {
  if (inner_case() == kBool) {
    return _impl_.inner_.bool__;
  }
  return false;
}
inline void ValueType::_internal_set_bool_(bool value) {
  if (inner_case() != kBool) {
    clear_inner();
    set_has_bool_();
  }
  _impl_.inner_.bool__ = value;
}

// int32 short = 3;
inline bool ValueType::has_short_() const {
  return inner_case() == kShort;
}
inline void ValueType::set_has_short_() {
  _impl_._oneof_case_[0] = kShort;
}
inline void ValueType::clear_short_() {
  if (inner_case() == kShort) {
    _impl_.inner_.short__ = 0;
    clear_has_inner();
  }
}
inline ::int32_t ValueType::short_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.short)
  return _internal_short_();
}
inline void ValueType::set_short_(::int32_t value) {
  _internal_set_short_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.short)
}
inline ::int32_t ValueType::_internal_short_() const {
  if (inner_case() == kShort) {
    return _impl_.inner_.short__;
  }
  return 0;
}
inline void ValueType::_internal_set_short_(::int32_t value) {
  if (inner_case() != kShort) {
    clear_inner();
    set_has_short_();
  }
  _impl_.inner_.short__ = value;
}

// int32 int = 4;
inline bool ValueType::has_int_() const {
  return inner_case() == kInt;
}
inline void ValueType::set_has_int_() {
  _impl_._oneof_case_[0] = kInt;
}
inline void ValueType::clear_int_() {
  if (inner_case() == kInt) {
    _impl_.inner_.int__ = 0;
    clear_has_inner();
  }
}
inline ::int32_t ValueType::int_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.int)
  return _internal_int_();
}
inline void ValueType::set_int_(::int32_t value) {
  _internal_set_int_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.int)
}
inline ::int32_t ValueType::_internal_int_() const {
  if (inner_case() == kInt) {
    return _impl_.inner_.int__;
  }
  return 0;
}
inline void ValueType::_internal_set_int_(::int32_t value) {
  if (inner_case() != kInt) {
    clear_inner();
    set_has_int_();
  }
  _impl_.inner_.int__ = value;
}

// int64 long = 5;
inline bool ValueType::has_long_() const {
  return inner_case() == kLong;
}
inline void ValueType::set_has_long_() {
  _impl_._oneof_case_[0] = kLong;
}
inline void ValueType::clear_long_() {
  if (inner_case() == kLong) {
    _impl_.inner_.long__ = ::int64_t{0};
    clear_has_inner();
  }
}
inline ::int64_t ValueType::long_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.long)
  return _internal_long_();
}
inline void ValueType::set_long_(::int64_t value) {
  _internal_set_long_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.long)
}
inline ::int64_t ValueType::_internal_long_() const {
  if (inner_case() == kLong) {
    return _impl_.inner_.long__;
  }
  return ::int64_t{0};
}
inline void ValueType::_internal_set_long_(::int64_t value) {
  if (inner_case() != kLong) {
    clear_inner();
    set_has_long_();
  }
  _impl_.inner_.long__ = value;
}

// float float = 6;
inline bool ValueType::has_float_() const {
  return inner_case() == kFloat;
}
inline void ValueType::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void ValueType::clear_float_() {
  if (inner_case() == kFloat) {
    _impl_.inner_.float__ = 0;
    clear_has_inner();
  }
}
inline float ValueType::float_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.float)
  return _internal_float_();
}
inline void ValueType::set_float_(float value) {
  _internal_set_float_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.float)
}
inline float ValueType::_internal_float_() const {
  if (inner_case() == kFloat) {
    return _impl_.inner_.float__;
  }
  return 0;
}
inline void ValueType::_internal_set_float_(float value) {
  if (inner_case() != kFloat) {
    clear_inner();
    set_has_float_();
  }
  _impl_.inner_.float__ = value;
}

// double double = 7;
inline bool ValueType::has_double_() const {
  return inner_case() == kDouble;
}
inline void ValueType::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void ValueType::clear_double_() {
  if (inner_case() == kDouble) {
    _impl_.inner_.double__ = 0;
    clear_has_inner();
  }
}
inline double ValueType::double_() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.double)
  return _internal_double_();
}
inline void ValueType::set_double_(double value) {
  _internal_set_double_(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.double)
}
inline double ValueType::_internal_double_() const {
  if (inner_case() == kDouble) {
    return _impl_.inner_.double__;
  }
  return 0;
}
inline void ValueType::_internal_set_double_(double value) {
  if (inner_case() != kDouble) {
    clear_inner();
    set_has_double_();
  }
  _impl_.inner_.double__ = value;
}

// .google.protobuf.Timestamp naive_date = 8;
inline bool ValueType::has_naive_date() const {
  return inner_case() == kNaiveDate;
}
inline bool ValueType::_internal_has_naive_date() const {
  return inner_case() == kNaiveDate;
}
inline void ValueType::set_has_naive_date() {
  _impl_._oneof_case_[0] = kNaiveDate;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::release_naive_date() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.naive_date)
  if (inner_case() == kNaiveDate) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.naive_date_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.inner_.naive_date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::_internal_naive_date() const {
  return inner_case() == kNaiveDate
      ? *_impl_.inner_.naive_date_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::naive_date() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.naive_date)
  return _internal_naive_date();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::unsafe_arena_release_naive_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.ValueType.naive_date)
  if (inner_case() == kNaiveDate) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.naive_date_;
    _impl_.inner_.naive_date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_naive_date(::PROTOBUF_NAMESPACE_ID::Timestamp* naive_date) {
  clear_inner();
  if (naive_date) {
    set_has_naive_date();
    _impl_.inner_.naive_date_ = naive_date;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.ValueType.naive_date)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::_internal_mutable_naive_date() {
  if (inner_case() != kNaiveDate) {
    clear_inner();
    set_has_naive_date();
    _impl_.inner_.naive_date_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.inner_.naive_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::mutable_naive_date() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_naive_date();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.naive_date)
  return _msg;
}

// .google.protobuf.Timestamp naive_datetime = 9;
inline bool ValueType::has_naive_datetime() const {
  return inner_case() == kNaiveDatetime;
}
inline bool ValueType::_internal_has_naive_datetime() const {
  return inner_case() == kNaiveDatetime;
}
inline void ValueType::set_has_naive_datetime() {
  _impl_._oneof_case_[0] = kNaiveDatetime;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::release_naive_datetime() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.naive_datetime)
  if (inner_case() == kNaiveDatetime) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.naive_datetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.inner_.naive_datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::_internal_naive_datetime() const {
  return inner_case() == kNaiveDatetime
      ? *_impl_.inner_.naive_datetime_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::naive_datetime() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.naive_datetime)
  return _internal_naive_datetime();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::unsafe_arena_release_naive_datetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.ValueType.naive_datetime)
  if (inner_case() == kNaiveDatetime) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.naive_datetime_;
    _impl_.inner_.naive_datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_naive_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* naive_datetime) {
  clear_inner();
  if (naive_datetime) {
    set_has_naive_datetime();
    _impl_.inner_.naive_datetime_ = naive_datetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.ValueType.naive_datetime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::_internal_mutable_naive_datetime() {
  if (inner_case() != kNaiveDatetime) {
    clear_inner();
    set_has_naive_datetime();
    _impl_.inner_.naive_datetime_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.inner_.naive_datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::mutable_naive_datetime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_naive_datetime();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.naive_datetime)
  return _msg;
}

// .google.protobuf.Timestamp utc_datetime = 10;
inline bool ValueType::has_utc_datetime() const {
  return inner_case() == kUtcDatetime;
}
inline bool ValueType::_internal_has_utc_datetime() const {
  return inner_case() == kUtcDatetime;
}
inline void ValueType::set_has_utc_datetime() {
  _impl_._oneof_case_[0] = kUtcDatetime;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::release_utc_datetime() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.utc_datetime)
  if (inner_case() == kUtcDatetime) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.utc_datetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.inner_.utc_datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::_internal_utc_datetime() const {
  return inner_case() == kUtcDatetime
      ? *_impl_.inner_.utc_datetime_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ValueType::utc_datetime() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.utc_datetime)
  return _internal_utc_datetime();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::unsafe_arena_release_utc_datetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fivetran_sdk.ValueType.utc_datetime)
  if (inner_case() == kUtcDatetime) {
    clear_has_inner();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.inner_.utc_datetime_;
    _impl_.inner_.utc_datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_utc_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* utc_datetime) {
  clear_inner();
  if (utc_datetime) {
    set_has_utc_datetime();
    _impl_.inner_.utc_datetime_ = utc_datetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.ValueType.utc_datetime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::_internal_mutable_utc_datetime() {
  if (inner_case() != kUtcDatetime) {
    clear_inner();
    set_has_utc_datetime();
    _impl_.inner_.utc_datetime_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.inner_.utc_datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ValueType::mutable_utc_datetime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_utc_datetime();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.utc_datetime)
  return _msg;
}

// string decimal = 11;
inline bool ValueType::has_decimal() const {
  return inner_case() == kDecimal;
}
inline void ValueType::set_has_decimal() {
  _impl_._oneof_case_[0] = kDecimal;
}
inline void ValueType::clear_decimal() {
  if (inner_case() == kDecimal) {
    _impl_.inner_.decimal_.Destroy();
    clear_has_inner();
  }
}
inline const std::string& ValueType::decimal() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.decimal)
  return _internal_decimal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueType::set_decimal(Arg_&& arg,
                                                     Args_... args) {
  if (inner_case() != kDecimal) {
    clear_inner();

    set_has_decimal();
    _impl_.inner_.decimal_.InitDefault();
  }
  _impl_.inner_.decimal_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.decimal)
}
inline std::string* ValueType::mutable_decimal() {
  std::string* _s = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.decimal)
  return _s;
}
inline const std::string& ValueType::_internal_decimal() const {
  if (inner_case() != kDecimal) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.inner_.decimal_.Get();
}
inline void ValueType::_internal_set_decimal(const std::string& value) {
  if (inner_case() != kDecimal) {
    clear_inner();

    set_has_decimal();
    _impl_.inner_.decimal_.InitDefault();
  }


  _impl_.inner_.decimal_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueType::_internal_mutable_decimal() {
  if (inner_case() != kDecimal) {
    clear_inner();

    set_has_decimal();
    _impl_.inner_.decimal_.InitDefault();
  }
  return _impl_.inner_.decimal_.Mutable( GetArenaForAllocation());
}
inline std::string* ValueType::release_decimal() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.decimal)
  if (inner_case() != kDecimal) {
    return nullptr;
  }
  clear_has_inner();
  return _impl_.inner_.decimal_.Release();
}
inline void ValueType::set_allocated_decimal(std::string* value) {
  if (has_inner()) {
    clear_inner();
  }
  if (value != nullptr) {
    set_has_decimal();
    _impl_.inner_.decimal_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ValueType.decimal)
}

// bytes binary = 12;
inline bool ValueType::has_binary() const {
  return inner_case() == kBinary;
}
inline void ValueType::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void ValueType::clear_binary() {
  if (inner_case() == kBinary) {
    _impl_.inner_.binary_.Destroy();
    clear_has_inner();
  }
}
inline const std::string& ValueType::binary() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.binary)
  return _internal_binary();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueType::set_binary(Arg_&& arg,
                                                     Args_... args) {
  if (inner_case() != kBinary) {
    clear_inner();

    set_has_binary();
    _impl_.inner_.binary_.InitDefault();
  }
  _impl_.inner_.binary_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.binary)
}
inline std::string* ValueType::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.binary)
  return _s;
}
inline const std::string& ValueType::_internal_binary() const {
  if (inner_case() != kBinary) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.inner_.binary_.Get();
}
inline void ValueType::_internal_set_binary(const std::string& value) {
  if (inner_case() != kBinary) {
    clear_inner();

    set_has_binary();
    _impl_.inner_.binary_.InitDefault();
  }


  _impl_.inner_.binary_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueType::_internal_mutable_binary() {
  if (inner_case() != kBinary) {
    clear_inner();

    set_has_binary();
    _impl_.inner_.binary_.InitDefault();
  }
  return _impl_.inner_.binary_.Mutable( GetArenaForAllocation());
}
inline std::string* ValueType::release_binary() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.binary)
  if (inner_case() != kBinary) {
    return nullptr;
  }
  clear_has_inner();
  return _impl_.inner_.binary_.Release();
}
inline void ValueType::set_allocated_binary(std::string* value) {
  if (has_inner()) {
    clear_inner();
  }
  if (value != nullptr) {
    set_has_binary();
    _impl_.inner_.binary_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ValueType.binary)
}

// string string = 13;
inline bool ValueType::has_string() const {
  return inner_case() == kString;
}
inline void ValueType::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void ValueType::clear_string() {
  if (inner_case() == kString) {
    _impl_.inner_.string_.Destroy();
    clear_has_inner();
  }
}
inline const std::string& ValueType::string() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.string)
  return _internal_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueType::set_string(Arg_&& arg,
                                                     Args_... args) {
  if (inner_case() != kString) {
    clear_inner();

    set_has_string();
    _impl_.inner_.string_.InitDefault();
  }
  _impl_.inner_.string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.string)
}
inline std::string* ValueType::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.string)
  return _s;
}
inline const std::string& ValueType::_internal_string() const {
  if (inner_case() != kString) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.inner_.string_.Get();
}
inline void ValueType::_internal_set_string(const std::string& value) {
  if (inner_case() != kString) {
    clear_inner();

    set_has_string();
    _impl_.inner_.string_.InitDefault();
  }


  _impl_.inner_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueType::_internal_mutable_string() {
  if (inner_case() != kString) {
    clear_inner();

    set_has_string();
    _impl_.inner_.string_.InitDefault();
  }
  return _impl_.inner_.string_.Mutable( GetArenaForAllocation());
}
inline std::string* ValueType::release_string() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.string)
  if (inner_case() != kString) {
    return nullptr;
  }
  clear_has_inner();
  return _impl_.inner_.string_.Release();
}
inline void ValueType::set_allocated_string(std::string* value) {
  if (has_inner()) {
    clear_inner();
  }
  if (value != nullptr) {
    set_has_string();
    _impl_.inner_.string_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ValueType.string)
}

// string json = 14;
inline bool ValueType::has_json() const {
  return inner_case() == kJson;
}
inline void ValueType::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline void ValueType::clear_json() {
  if (inner_case() == kJson) {
    _impl_.inner_.json_.Destroy();
    clear_has_inner();
  }
}
inline const std::string& ValueType::json() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.json)
  return _internal_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueType::set_json(Arg_&& arg,
                                                     Args_... args) {
  if (inner_case() != kJson) {
    clear_inner();

    set_has_json();
    _impl_.inner_.json_.InitDefault();
  }
  _impl_.inner_.json_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.json)
}
inline std::string* ValueType::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.json)
  return _s;
}
inline const std::string& ValueType::_internal_json() const {
  if (inner_case() != kJson) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.inner_.json_.Get();
}
inline void ValueType::_internal_set_json(const std::string& value) {
  if (inner_case() != kJson) {
    clear_inner();

    set_has_json();
    _impl_.inner_.json_.InitDefault();
  }


  _impl_.inner_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueType::_internal_mutable_json() {
  if (inner_case() != kJson) {
    clear_inner();

    set_has_json();
    _impl_.inner_.json_.InitDefault();
  }
  return _impl_.inner_.json_.Mutable( GetArenaForAllocation());
}
inline std::string* ValueType::release_json() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.json)
  if (inner_case() != kJson) {
    return nullptr;
  }
  clear_has_inner();
  return _impl_.inner_.json_.Release();
}
inline void ValueType::set_allocated_json(std::string* value) {
  if (has_inner()) {
    clear_inner();
  }
  if (value != nullptr) {
    set_has_json();
    _impl_.inner_.json_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ValueType.json)
}

// string xml = 15;
inline bool ValueType::has_xml() const {
  return inner_case() == kXml;
}
inline void ValueType::set_has_xml() {
  _impl_._oneof_case_[0] = kXml;
}
inline void ValueType::clear_xml() {
  if (inner_case() == kXml) {
    _impl_.inner_.xml_.Destroy();
    clear_has_inner();
  }
}
inline const std::string& ValueType::xml() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.ValueType.xml)
  return _internal_xml();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueType::set_xml(Arg_&& arg,
                                                     Args_... args) {
  if (inner_case() != kXml) {
    clear_inner();

    set_has_xml();
    _impl_.inner_.xml_.InitDefault();
  }
  _impl_.inner_.xml_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.ValueType.xml)
}
inline std::string* ValueType::mutable_xml() {
  std::string* _s = _internal_mutable_xml();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.ValueType.xml)
  return _s;
}
inline const std::string& ValueType::_internal_xml() const {
  if (inner_case() != kXml) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.inner_.xml_.Get();
}
inline void ValueType::_internal_set_xml(const std::string& value) {
  if (inner_case() != kXml) {
    clear_inner();

    set_has_xml();
    _impl_.inner_.xml_.InitDefault();
  }


  _impl_.inner_.xml_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueType::_internal_mutable_xml() {
  if (inner_case() != kXml) {
    clear_inner();

    set_has_xml();
    _impl_.inner_.xml_.InitDefault();
  }
  return _impl_.inner_.xml_.Mutable( GetArenaForAllocation());
}
inline std::string* ValueType::release_xml() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.ValueType.xml)
  if (inner_case() != kXml) {
    return nullptr;
  }
  clear_has_inner();
  return _impl_.inner_.xml_.Release();
}
inline void ValueType::set_allocated_xml(std::string* value) {
  if (has_inner()) {
    clear_inner();
  }
  if (value != nullptr) {
    set_has_xml();
    _impl_.inner_.xml_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.ValueType.xml)
}

inline bool ValueType::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void ValueType::clear_has_inner() {
  _impl_._oneof_case_[0] = INNER_NOT_SET;
}
inline ValueType::InnerCase ValueType::inner_case() const {
  return ValueType::InnerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Table

// string name = 1;
inline void Table::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Table::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Table.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.Table.name)
}
inline std::string* Table::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Table.name)
  return _s;
}
inline const std::string& Table::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Table::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Table::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Table::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.Table.name)
  return _impl_.name_.Release();
}
inline void Table::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.Table.name)
}

// repeated .fivetran_sdk.Column columns = 2;
inline int Table::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int Table::columns_size() const {
  return _internal_columns_size();
}
inline void Table::clear_columns() {
  _internal_mutable_columns()->Clear();
}
inline ::fivetran_sdk::Column* Table::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Table.columns)
  return _internal_mutable_columns()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Column >*
Table::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:fivetran_sdk.Table.columns)
  return _internal_mutable_columns();
}
inline const ::fivetran_sdk::Column& Table::_internal_columns(int index) const {
  return _internal_columns().Get(index);
}
inline const ::fivetran_sdk::Column& Table::columns(int index) const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Table.columns)
  return _internal_columns(index);
}
inline ::fivetran_sdk::Column* Table::_internal_add_columns() {
  return _internal_mutable_columns()->Add();
}
inline ::fivetran_sdk::Column* Table::add_columns() {
  ::fivetran_sdk::Column* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:fivetran_sdk.Table.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fivetran_sdk::Column >&
Table::columns() const {
  // @@protoc_insertion_point(field_list:fivetran_sdk.Table.columns)
  return _internal_columns();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Column>&
Table::_internal_columns() const {
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::fivetran_sdk::Column>*
Table::_internal_mutable_columns() {
  return &_impl_.columns_;
}

// -------------------------------------------------------------------

// Column

// string name = 1;
inline void Column::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Column.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Column::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fivetran_sdk.Column.name)
}
inline std::string* Column::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Column.name)
  return _s;
}
inline const std::string& Column::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Column::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Column::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.Column.name)
  return _impl_.name_.Release();
}
inline void Column::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.Column.name)
}

// .fivetran_sdk.DataType type = 2;
inline void Column::clear_type() {
  _impl_.type_ = 0;
}
inline ::fivetran_sdk::DataType Column::type() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Column.type)
  return _internal_type();
}
inline void Column::set_type(::fivetran_sdk::DataType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.Column.type)
}
inline ::fivetran_sdk::DataType Column::_internal_type() const {
  return static_cast<::fivetran_sdk::DataType>(_impl_.type_);
}
inline void Column::_internal_set_type(::fivetran_sdk::DataType value) {
  ;
  _impl_.type_ = value;
}

// bool primary_key = 3;
inline void Column::clear_primary_key() {
  _impl_.primary_key_ = false;
}
inline bool Column::primary_key() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Column.primary_key)
  return _internal_primary_key();
}
inline void Column::set_primary_key(bool value) {
  _internal_set_primary_key(value);
  // @@protoc_insertion_point(field_set:fivetran_sdk.Column.primary_key)
}
inline bool Column::_internal_primary_key() const {
  return _impl_.primary_key_;
}
inline void Column::_internal_set_primary_key(bool value) {
  ;
  _impl_.primary_key_ = value;
}

// optional .fivetran_sdk.DecimalParams decimal = 4;
inline bool Column::has_decimal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.decimal_ != nullptr);
  return value;
}
inline void Column::clear_decimal() {
  if (_impl_.decimal_ != nullptr) _impl_.decimal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::fivetran_sdk::DecimalParams& Column::_internal_decimal() const {
  const ::fivetran_sdk::DecimalParams* p = _impl_.decimal_;
  return p != nullptr ? *p : reinterpret_cast<const ::fivetran_sdk::DecimalParams&>(
      ::fivetran_sdk::_DecimalParams_default_instance_);
}
inline const ::fivetran_sdk::DecimalParams& Column::decimal() const {
  // @@protoc_insertion_point(field_get:fivetran_sdk.Column.decimal)
  return _internal_decimal();
}
inline void Column::unsafe_arena_set_allocated_decimal(
    ::fivetran_sdk::DecimalParams* decimal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.decimal_);
  }
  _impl_.decimal_ = decimal;
  if (decimal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fivetran_sdk.Column.decimal)
}
inline ::fivetran_sdk::DecimalParams* Column::release_decimal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::DecimalParams* temp = _impl_.decimal_;
  _impl_.decimal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fivetran_sdk::DecimalParams* Column::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_release:fivetran_sdk.Column.decimal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fivetran_sdk::DecimalParams* temp = _impl_.decimal_;
  _impl_.decimal_ = nullptr;
  return temp;
}
inline ::fivetran_sdk::DecimalParams* Column::_internal_mutable_decimal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.decimal_ == nullptr) {
    auto* p = CreateMaybeMessage<::fivetran_sdk::DecimalParams>(GetArenaForAllocation());
    _impl_.decimal_ = p;
  }
  return _impl_.decimal_;
}
inline ::fivetran_sdk::DecimalParams* Column::mutable_decimal() {
  ::fivetran_sdk::DecimalParams* _msg = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:fivetran_sdk.Column.decimal)
  return _msg;
}
inline void Column::set_allocated_decimal(::fivetran_sdk::DecimalParams* decimal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.decimal_;
  }
  if (decimal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decimal);
    if (message_arena != submessage_arena) {
      decimal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decimal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.decimal_ = decimal;
  // @@protoc_insertion_point(field_set_allocated:fivetran_sdk.Column.decimal)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace fivetran_sdk


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::fivetran_sdk::TextField> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::fivetran_sdk::TextField>() {
  return ::fivetran_sdk::TextField_descriptor();
}
template <>
struct is_proto_enum<::fivetran_sdk::DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::fivetran_sdk::DataType>() {
  return ::fivetran_sdk::DataType_descriptor();
}
template <>
struct is_proto_enum<::fivetran_sdk::OpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::fivetran_sdk::OpType>() {
  return ::fivetran_sdk::OpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
